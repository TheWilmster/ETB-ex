// Script generated by loypoll's decompiler
/// GMS1 Compatibility Scripts
function __global_object_depths()
{
	// Initialise the global array that allows the lookup of the depth of a given object
	// GM2.0 does not have a depth on objects so on import from 1.x a global array is created
	// NOTE: MacroExpansion is used to insert the array initialisation at import time
	gml_pragma( "global", "__global_object_depths()");
	
	// insert the generated arrays here
	global.__objectDepths[0] = 88; // obj_lap1end
	global.__objectDepths[1] = 88; // obj_lap1
	global.__objectDepths[2] = -9998; // obj_pause
	global.__objectDepths[3] = 0; // obj_music
	global.__objectDepths[4] = -9999; // obj_rank
	global.__objectDepths[5] = 0; // obj_camera
	global.__objectDepths[6] = 0; // obj_collisionparent
	global.__objectDepths[7] = 0; // obj_destructibles
	global.__objectDepths[8] = 0; // obj_enemiesbumpable
	global.__objectDepths[9] = 0; // obj_bumpable
	global.__objectDepths[10] = 0; // obj_controller
	global.__objectDepths[11] = 0; // obj_pixelslope
	global.__objectDepths[12] = 0; // obj_chainsawhitbox
	global.__objectDepths[13] = 0; // obj_chainsawpogohitbox
	global.__objectDepths[14] = 0; // obj_swordhitbox
	global.__objectDepths[15] = 0; // obj_pistolbullet
	global.__objectDepths[16] = 0; // obj_shotgunbullet
	global.__objectDepths[17] = 1; // obj_hallway
	global.__objectDepths[18] = 0; // obj_hurtbox
	global.__objectDepths[19] = -7; // obj_noise_normalT1
	global.__objectDepths[20] = -10; // obj_player
	global.__objectDepths[21] = 0; // obj_baddie
	global.__objectDepths[22] = 0; // obj_baddiedead
	global.__objectDepths[23] = 0; // obj_forkhitbox
	global.__objectDepths[24] = 0; // obj_forknight
	global.__objectDepths[25] = -1; // obj_forknightdead
	global.__objectDepths[26] = 0; // obj_pepgoblin
	global.__objectDepths[27] = -1; // obj_pepgoblindead
	global.__objectDepths[28] = 0; // obj_coolpineahitbox
	global.__objectDepths[29] = 0; // obj_coolpinea
	global.__objectDepths[30] = -1; // obj_coolpineadead
	global.__objectDepths[31] = 0; // obj_pepperman
	global.__objectDepths[32] = -2; // obj_enemymeteor
	global.__objectDepths[33] = 0; // obj_sausageman
	global.__objectDepths[34] = 0; // obj_pizzagoblin
	global.__objectDepths[35] = 0; // obj_slime
	global.__objectDepths[36] = 0; // obj_sausagemancigar
	global.__objectDepths[37] = -7; // obj_bombexplosion
	global.__objectDepths[38] = 0; // obj_bomb
	global.__objectDepths[39] = 0; // obj_enemyblock
	global.__objectDepths[40] = 0; // obj_enemyblockdead
	global.__objectDepths[41] = 0; // obj_monsterdetection
	global.__objectDepths[42] = 0; // obj_smollmonsterdetection
	global.__objectDepths[43] = 0; // obj_monster
	global.__objectDepths[44] = 0; // obj_chasingmonster
	global.__objectDepths[45] = 0; // obj_chasingmonsterdark
	global.__objectDepths[46] = 0; // obj_smollmonster
	global.__objectDepths[47] = 0; // obj_ogre
	global.__objectDepths[48] = 0; // obj_slimedead
	global.__objectDepths[49] = 0; // obj_piraneapple
	global.__objectDepths[50] = 0; // obj_flyingenemydead
	global.__objectDepths[51] = 0; // obj_flyingenemy
	global.__objectDepths[52] = 0; // obj_hardass
	global.__objectDepths[53] = 0; // obj_trashdead
	global.__objectDepths[54] = 3; // obj_treasure1
	global.__objectDepths[55] = 0; // obj_swordstone
	global.__objectDepths[56] = 999; // obj_slopes
	global.__objectDepths[57] = 0; // obj_exitgate
	global.__objectDepths[58] = 0; // obj_bowlingball
	global.__objectDepths[59] = 2; // obj_pizzaboxunopen
	global.__objectDepths[60] = 0; // obj_grindrailnormal
	global.__objectDepths[61] = 999; // obj_wall
	global.__objectDepths[62] = 2; // obj_onewaywall
	global.__objectDepths[63] = 0; // obj_onewaysolid
	global.__objectDepths[64] = 0; // obj_skateboard
	global.__objectDepths[65] = 1; // obj_bigcollect
	global.__objectDepths[66] = 1; // obj_collect
	global.__objectDepths[67] = 1; // obj_ammo
	global.__objectDepths[68] = 0; // obj_key
	global.__objectDepths[69] = 0; // obj_pizzastand
	global.__objectDepths[70] = -1; // obj_pizzabox
	global.__objectDepths[71] = 0; // obj_hungrypillar
	global.__objectDepths[72] = 0; // obj_pizzakinshroom
	global.__objectDepths[73] = 0; // obj_pizzakincheese
	global.__objectDepths[74] = 0; // obj_pizzakintomato
	global.__objectDepths[75] = 0; // obj_pizzakinsausage
	global.__objectDepths[76] = 0; // obj_pizzakinpineapple
	global.__objectDepths[77] = 5; // obj_keydoor
	global.__objectDepths[78] = 5; // obj_door2
	global.__objectDepths[79] = 5; // obj_goldendoor
	global.__objectDepths[80] = 1; // obj_doorblocked
	global.__objectDepths[81] = 5; // obj_door
	global.__objectDepths[82] = 2; // obj_spike
	global.__objectDepths[83] = 1; // obj_ladder
	global.__objectDepths[84] = 0; // obj_enemylimit
	global.__objectDepths[85] = 2; // obj_destroyable
	global.__objectDepths[86] = 0; // obj_destroyable2
	global.__objectDepths[87] = 0; // obj_destroyable2_big
	global.__objectDepths[88] = 0; // obj_destroyable3
	global.__objectDepths[89] = 2; // obj_metalblock
	global.__objectDepths[90] = 2; // obj_glassblock
	global.__objectDepths[91] = 0; // obj_breakabledoor
	global.__objectDepths[92] = 0; // obj_secretwall
	global.__objectDepths[93] = 0; // obj_secretwall2
	global.__objectDepths[94] = 0; // obj_secretwall3
	global.__objectDepths[95] = 0; // obj_slipnslide
	global.__objectDepths[96] = 0; // obj_wetfloor
	global.__objectDepths[97] = 0; // obj_hook
	global.__objectDepths[98] = 0; // obj_hookup
	global.__objectDepths[99] = 0; // obj_hookleft
	global.__objectDepths[100] = 55; // obj_water
	global.__objectDepths[101] = 55; // obj_water2
	global.__objectDepths[102] = 55; // obj_current2
	global.__objectDepths[103] = 55; // obj_current
	global.__objectDepths[104] = 0; // obj_hookend
	global.__objectDepths[105] = 0; // obj_barrelspawner
	global.__objectDepths[106] = 0; // obj_transformbarrelspawner
	global.__objectDepths[107] = 1; // obj_transformbarrel
	global.__objectDepths[108] = 0; // obj_barrel
	global.__objectDepths[109] = 1; // obj_barrelfloat
	global.__objectDepths[110] = 0; // obj_onewaywatersolid
	global.__objectDepths[111] = 0; // obj_boulderspawner
	global.__objectDepths[112] = 0; // obj_boulder
	global.__objectDepths[113] = 0; // spr_transformboulderspawner
	global.__objectDepths[114] = 0; // obj_transformboulderspawnerleft
	global.__objectDepths[115] = 0; // obj_transformboulderleft
	global.__objectDepths[116] = 0; // obj_transformboulder
	global.__objectDepths[117] = 0; // obj_flamesspawner
	global.__objectDepths[118] = 0; // obj_flames
	global.__objectDepths[119] = 0; // obj_crusher
	global.__objectDepths[120] = 0; // obj_crusherdetection
	global.__objectDepths[121] = 0; // obj_ballspawner
	global.__objectDepths[122] = 0; // obj_runonball
	global.__objectDepths[123] = 0; // obj_ball
	global.__objectDepths[124] = 0; // obj_spring
	global.__objectDepths[125] = 0; // obj_disclaimer
	global.__objectDepths[126] = -2; // obj_glassdebris
	global.__objectDepths[127] = 0; // obj_vomit
	global.__objectDepths[128] = 0; // obj_drip
	global.__objectDepths[129] = 0; // obj_dripspawner
	global.__objectDepths[130] = 999; // obj_wave
	global.__objectDepths[131] = 0; // obj_thunder
	global.__objectDepths[132] = 3; // obj_sign
	global.__objectDepths[133] = -7; // obj_chargeeffect
	global.__objectDepths[134] = 0; // obj_pogoeffect
	global.__objectDepths[135] = -9999; // obj_exit
	global.__objectDepths[136] = -9999; // obj_retry
	global.__objectDepths[137] = -9999; // obj_pausearm
	global.__objectDepths[138] = 0; // obj_youarehere
	global.__objectDepths[139] = 10; // obj_timesup
	global.__objectDepths[140] = 0; // obj_chainsaweffect
	global.__objectDepths[141] = 0; // obj_explosioneffect
	global.__objectDepths[142] = 0; // obj_baddiegibs
	global.__objectDepths[143] = 0; // obj_pistoleffect
	global.__objectDepths[144] = 0; // obj_shotgunjumpeffect
	global.__objectDepths[145] = -10; // obj_superslameffect
	global.__objectDepths[146] = -10; // obj_spikehurteffect
	global.__objectDepths[147] = 0; // obj_skateboarddebris1
	global.__objectDepths[148] = 0; // obj_skateboarddebris2
	global.__objectDepths[149] = -2; // obj_stompeffect
	global.__objectDepths[150] = 0; // obj_jumpdust
	global.__objectDepths[151] = 0; // obj_grindeffect
	global.__objectDepths[152] = -10; // obj_punchdust
	global.__objectDepths[153] = -9999; // obj_fadeout
	global.__objectDepths[154] = -6; // obj_endlevelfade
	global.__objectDepths[155] = -1; // obj_bossdefeatflash
	global.__objectDepths[156] = -9998; // obj_light
	global.__objectDepths[157] = -9999; // obj_scaryeyes
	global.__objectDepths[158] = -9997; // obj_darkroom
	global.__objectDepths[159] = -9999; // obj_googlyeyes
	global.__objectDepths[160] = 2; // obj_hard
	global.__objectDepths[161] = 2; // obj_easy
	global.__objectDepths[162] = 0; // obj_title
	global.__objectDepths[163] = -7; // obj_10
	global.__objectDepths[164] = -7; // obj_20
	global.__objectDepths[165] = -7; // obj_40
	global.__objectDepths[166] = -7; // obj_80
	global.__objectDepths[167] = -7; // obj_100
	global.__objectDepths[168] = 0; // obj_lighting
	global.__objectDepths[169] = 0; // obj_bangeffect
	global.__objectDepths[170] = -6; // obj_bubble
	global.__objectDepths[171] = 0; // obj_result
	global.__objectDepths[172] = 0; // obj_cutscene_upstairs
	global.__objectDepths[173] = -1; // obj_blackbars
	global.__objectDepths[174] = 2; // obj_lightstart
	global.__objectDepths[175] = 999; // obj_lamp
	global.__objectDepths[176] = 0; // obj_bumpeffect
	global.__objectDepths[177] = 0; // obj_waterdrop
	global.__objectDepths[178] = 0; // obj_keyeffect
	global.__objectDepths[179] = -6; // obj_doortransition
	global.__objectDepths[180] = -3; // obj_doortransitionend
	global.__objectDepths[181] = -6; // obj_doortransition2
	global.__objectDepths[182] = -2; // obj_wooddebris
	global.__objectDepths[183] = -2; // obj_debris
	global.__objectDepths[184] = -7; // obj_knightdebris
	global.__objectDepths[185] = -2; // object189
	global.__objectDepths[186] = -2; // obj_metaldebris
	global.__objectDepths[187] = 0; // obj_slimedebris
	global.__objectDepths[188] = -4; // obj_lock
	global.__objectDepths[189] = -6; // obj_slidecloud
	global.__objectDepths[190] = -6; // obj_landcloud
	global.__objectDepths[191] = -6; // obj_dashcloud
	global.__objectDepths[192] = -6; // obj_cloudeffect
	global.__objectDepths[193] = -4; // obj_mach3effect
	global.__objectDepths[194] = -4; // obj_mach2effect
	global.__objectDepths[195] = 0; // obj_machalleffect
	global.__objectDepths[196] = -5; // obj_mach3effect1
	global.__objectDepths[197] = -5; // obj_mach3effect2
	global.__objectDepths[198] = -5; // obj_machfreefall1
	global.__objectDepths[199] = -5; // obj_machfreefall2
	global.__objectDepths[200] = -5; // obj_machsuperjump1
	global.__objectDepths[201] = -5; // obj_machsuperjump2
	global.__objectDepths[202] = 0; // obj_null


	global.__objectNames[0] = "obj_lap1end";
	global.__objectNames[1] = "obj_lap1";
	global.__objectNames[2] = "obj_pause";
	global.__objectNames[3] = "obj_music";
	global.__objectNames[4] = "obj_rank";
	global.__objectNames[5] = "obj_camera";
	global.__objectNames[6] = "obj_collisionparent";
	global.__objectNames[7] = "obj_destructibles";
	global.__objectNames[8] = "obj_enemiesbumpable";
	global.__objectNames[9] = "obj_bumpable";
	global.__objectNames[10] = "obj_controller";
	global.__objectNames[11] = "obj_pixelslope";
	global.__objectNames[12] = "obj_chainsawhitbox";
	global.__objectNames[13] = "obj_chainsawpogohitbox";
	global.__objectNames[14] = "obj_swordhitbox";
	global.__objectNames[15] = "obj_pistolbullet";
	global.__objectNames[16] = "obj_shotgunbullet";
	global.__objectNames[17] = "obj_hallway";
	global.__objectNames[18] = "obj_hurtbox";
	global.__objectNames[19] = "obj_noise_normalT1";
	global.__objectNames[20] = "obj_player";
	global.__objectNames[21] = "obj_baddie";
	global.__objectNames[22] = "obj_baddiedead";
	global.__objectNames[23] = "obj_forkhitbox";
	global.__objectNames[24] = "obj_forknight";
	global.__objectNames[25] = "obj_forknightdead";
	global.__objectNames[26] = "obj_pepgoblin";
	global.__objectNames[27] = "obj_pepgoblindead";
	global.__objectNames[28] = "obj_coolpineahitbox";
	global.__objectNames[29] = "obj_coolpinea";
	global.__objectNames[30] = "obj_coolpineadead";
	global.__objectNames[31] = "obj_pepperman";
	global.__objectNames[32] = "obj_enemymeteor";
	global.__objectNames[33] = "obj_sausageman";
	global.__objectNames[34] = "obj_pizzagoblin";
	global.__objectNames[35] = "obj_slime";
	global.__objectNames[36] = "obj_sausagemancigar";
	global.__objectNames[37] = "obj_bombexplosion";
	global.__objectNames[38] = "obj_bomb";
	global.__objectNames[39] = "obj_enemyblock";
	global.__objectNames[40] = "obj_enemyblockdead";
	global.__objectNames[41] = "obj_monsterdetection";
	global.__objectNames[42] = "obj_smollmonsterdetection";
	global.__objectNames[43] = "obj_monster";
	global.__objectNames[44] = "obj_chasingmonster";
	global.__objectNames[45] = "obj_chasingmonsterdark";
	global.__objectNames[46] = "obj_smollmonster";
	global.__objectNames[47] = "obj_ogre";
	global.__objectNames[48] = "obj_slimedead";
	global.__objectNames[49] = "obj_piraneapple";
	global.__objectNames[50] = "obj_flyingenemydead";
	global.__objectNames[51] = "obj_flyingenemy";
	global.__objectNames[52] = "obj_hardass";
	global.__objectNames[53] = "obj_trashdead";
	global.__objectNames[54] = "obj_treasure1";
	global.__objectNames[55] = "obj_swordstone";
	global.__objectNames[56] = "obj_slopes";
	global.__objectNames[57] = "obj_exitgate";
	global.__objectNames[58] = "obj_bowlingball";
	global.__objectNames[59] = "obj_pizzaboxunopen";
	global.__objectNames[60] = "obj_grindrailnormal";
	global.__objectNames[61] = "obj_wall";
	global.__objectNames[62] = "obj_onewaywall";
	global.__objectNames[63] = "obj_onewaysolid";
	global.__objectNames[64] = "obj_skateboard";
	global.__objectNames[65] = "obj_bigcollect";
	global.__objectNames[66] = "obj_collect";
	global.__objectNames[67] = "obj_ammo";
	global.__objectNames[68] = "obj_key";
	global.__objectNames[69] = "obj_pizzastand";
	global.__objectNames[70] = "obj_pizzabox";
	global.__objectNames[71] = "obj_hungrypillar";
	global.__objectNames[72] = "obj_pizzakinshroom";
	global.__objectNames[73] = "obj_pizzakincheese";
	global.__objectNames[74] = "obj_pizzakintomato";
	global.__objectNames[75] = "obj_pizzakinsausage";
	global.__objectNames[76] = "obj_pizzakinpineapple";
	global.__objectNames[77] = "obj_keydoor";
	global.__objectNames[78] = "obj_door2";
	global.__objectNames[79] = "obj_goldendoor";
	global.__objectNames[80] = "obj_doorblocked";
	global.__objectNames[81] = "obj_door";
	global.__objectNames[82] = "obj_spike";
	global.__objectNames[83] = "obj_ladder";
	global.__objectNames[84] = "obj_enemylimit";
	global.__objectNames[85] = "obj_destroyable";
	global.__objectNames[86] = "obj_destroyable2";
	global.__objectNames[87] = "obj_destroyable2_big";
	global.__objectNames[88] = "obj_destroyable3";
	global.__objectNames[89] = "obj_metalblock";
	global.__objectNames[90] = "obj_glassblock";
	global.__objectNames[91] = "obj_breakabledoor";
	global.__objectNames[92] = "obj_secretwall";
	global.__objectNames[93] = "obj_secretwall2";
	global.__objectNames[94] = "obj_secretwall3";
	global.__objectNames[95] = "obj_slipnslide";
	global.__objectNames[96] = "obj_wetfloor";
	global.__objectNames[97] = "obj_hook";
	global.__objectNames[98] = "obj_hookup";
	global.__objectNames[99] = "obj_hookleft";
	global.__objectNames[100] = "obj_water";
	global.__objectNames[101] = "obj_water2";
	global.__objectNames[102] = "obj_current2";
	global.__objectNames[103] = "obj_current";
	global.__objectNames[104] = "obj_hookend";
	global.__objectNames[105] = "obj_barrelspawner";
	global.__objectNames[106] = "obj_transformbarrelspawner";
	global.__objectNames[107] = "obj_transformbarrel";
	global.__objectNames[108] = "obj_barrel";
	global.__objectNames[109] = "obj_barrelfloat";
	global.__objectNames[110] = "obj_onewaywatersolid";
	global.__objectNames[111] = "obj_boulderspawner";
	global.__objectNames[112] = "obj_boulder";
	global.__objectNames[113] = "spr_transformboulderspawner";
	global.__objectNames[114] = "obj_transformboulderspawnerleft";
	global.__objectNames[115] = "obj_transformboulderleft";
	global.__objectNames[116] = "obj_transformboulder";
	global.__objectNames[117] = "obj_flamesspawner";
	global.__objectNames[118] = "obj_flames";
	global.__objectNames[119] = "obj_crusher";
	global.__objectNames[120] = "obj_crusherdetection";
	global.__objectNames[121] = "obj_ballspawner";
	global.__objectNames[122] = "obj_runonball";
	global.__objectNames[123] = "obj_ball";
	global.__objectNames[124] = "obj_spring";
	global.__objectNames[125] = "obj_disclaimer";
	global.__objectNames[126] = "obj_glassdebris";
	global.__objectNames[127] = "obj_vomit";
	global.__objectNames[128] = "obj_drip";
	global.__objectNames[129] = "obj_dripspawner";
	global.__objectNames[130] = "obj_wave";
	global.__objectNames[131] = "obj_thunder";
	global.__objectNames[132] = "obj_sign";
	global.__objectNames[133] = "obj_chargeeffect";
	global.__objectNames[134] = "obj_pogoeffect";
	global.__objectNames[135] = "obj_exit";
	global.__objectNames[136] = "obj_retry";
	global.__objectNames[137] = "obj_pausearm";
	global.__objectNames[138] = "obj_youarehere";
	global.__objectNames[139] = "obj_timesup";
	global.__objectNames[140] = "obj_chainsaweffect";
	global.__objectNames[141] = "obj_explosioneffect";
	global.__objectNames[142] = "obj_baddiegibs";
	global.__objectNames[143] = "obj_pistoleffect";
	global.__objectNames[144] = "obj_shotgunjumpeffect";
	global.__objectNames[145] = "obj_superslameffect";
	global.__objectNames[146] = "obj_spikehurteffect";
	global.__objectNames[147] = "obj_skateboarddebris1";
	global.__objectNames[148] = "obj_skateboarddebris2";
	global.__objectNames[149] = "obj_stompeffect";
	global.__objectNames[150] = "obj_jumpdust";
	global.__objectNames[151] = "obj_grindeffect";
	global.__objectNames[152] = "obj_punchdust";
	global.__objectNames[153] = "obj_fadeout";
	global.__objectNames[154] = "obj_endlevelfade";
	global.__objectNames[155] = "obj_bossdefeatflash";
	global.__objectNames[156] = "obj_light";
	global.__objectNames[157] = "obj_scaryeyes";
	global.__objectNames[158] = "obj_darkroom";
	global.__objectNames[159] = "obj_googlyeyes";
	global.__objectNames[160] = "obj_hard";
	global.__objectNames[161] = "obj_easy";
	global.__objectNames[162] = "obj_title";
	global.__objectNames[163] = "obj_10";
	global.__objectNames[164] = "obj_20";
	global.__objectNames[165] = "obj_40";
	global.__objectNames[166] = "obj_80";
	global.__objectNames[167] = "obj_100";
	global.__objectNames[168] = "obj_lighting";
	global.__objectNames[169] = "obj_bangeffect";
	global.__objectNames[170] = "obj_bubble";
	global.__objectNames[171] = "obj_result";
	global.__objectNames[172] = "obj_cutscene_upstairs";
	global.__objectNames[173] = "obj_blackbars";
	global.__objectNames[174] = "obj_lightstart";
	global.__objectNames[175] = "obj_lamp";
	global.__objectNames[176] = "obj_bumpeffect";
	global.__objectNames[177] = "obj_waterdrop";
	global.__objectNames[178] = "obj_keyeffect";
	global.__objectNames[179] = "obj_doortransition";
	global.__objectNames[180] = "obj_doortransitionend";
	global.__objectNames[181] = "obj_doortransition2";
	global.__objectNames[182] = "obj_wooddebris";
	global.__objectNames[183] = "obj_debris";
	global.__objectNames[184] = "obj_knightdebris";
	global.__objectNames[185] = "object189";
	global.__objectNames[186] = "obj_metaldebris";
	global.__objectNames[187] = "obj_slimedebris";
	global.__objectNames[188] = "obj_lock";
	global.__objectNames[189] = "obj_slidecloud";
	global.__objectNames[190] = "obj_landcloud";
	global.__objectNames[191] = "obj_dashcloud";
	global.__objectNames[192] = "obj_cloudeffect";
	global.__objectNames[193] = "obj_mach3effect";
	global.__objectNames[194] = "obj_mach2effect";
	global.__objectNames[195] = "obj_machalleffect";
	global.__objectNames[196] = "obj_mach3effect1";
	global.__objectNames[197] = "obj_mach3effect2";
	global.__objectNames[198] = "obj_machfreefall1";
	global.__objectNames[199] = "obj_machfreefall2";
	global.__objectNames[200] = "obj_machsuperjump1";
	global.__objectNames[201] = "obj_machsuperjump2";
	global.__objectNames[202] = "obj_null";

	
	// create another array that has the correct entries
	var len = array_length(global.__objectDepths);
	global.__objectID2Depth = [];
	for( var i=0; i<len; ++i ) {
		var objID = asset_get_index( global.__objectNames[i] );
		if (objID >= 0) {
			global.__objectID2Depth[ objID ] = global.__objectDepths[i];
		} // end if
	} // end for
}

function __init_global()
{
	gml_pragma( "global", "__init_global();");
	
	// set any global defaults
	layer_force_draw_depth(true,0);		// force all layers to draw at depth 0
	draw_set_colour( c_black );
}

#region view

function room_set_view()
{
	/// @description Sets a view and its related attributes of a given room.
	/// @param ind The index of the room to set the view of.
	/// @param vind The view 'slot' to set, between 0 and 7.
	/// @param vis Whether the view is visible (true) or not (false).
	/// @param xview The x position of the left of the area the view captures.
	/// @param yview The y position of the top of the area the view captures.
	/// @param wview The width of the area the view captures.
	/// @param hview The height of the area the view captures.
	/// @param xport The x position of the left of the area the view occupies on-screen.
	/// @param yport The y position of the top of the area the view occupies on-screen.
	/// @param wport The width of the area the view occupies on-screen.
	/// @param hport The height of the area the view occupies on-screen.
	/// @param hborder The minimum horizontal space between the edge of the view and the object it is set to follow (before the view begins moving and if it is set to follow an object).
	/// @param vborder The minimum vertical space between the edge of the view and the object it is set to follow (before the view begins moving and if it is set to follow an object).
	/// @param hspeed The maximum horizontal speed the view can move at.
	/// @param vspeed The maximum vertical speed the view can move at.
	/// @param obj The object or instance to follow. -1 to disable object following.
	
	var __ind = argument0;
	var __vind = argument1;
	var __vis = argument2;
	var __xview = argument3;
	var __yview = argument4;
	var __wview = argument5;
	var __hview = argument6;
	var __xport = argument7;
	var __yport = argument8;
	var __wport = argument9;
	var __hport = argument10;
	var __hborder = argument11;
	var __vborder = argument12;
	var __hspeed = argument13;
	var __vspeed = argument14;
	var __obj = argument15;
	
	if (!room_exists(__ind))
	{
		show_debug_message("room_set_view: room " + string(__ind) + " does not exist");
		return -1;
	}
	
	if ((__vind < 0) || (__vind > 7))
	{
		show_debug_message("room_set_view: view index out of range");
		return -1;
	}
	
	// Create new camera with specified params
	var __newcam = camera_create_view(__xview, __yview, __wview, __hview, 0, __obj, __hspeed, __vspeed, __hborder, __vborder);
	
	// Get existing camera in room
	var __currcam = room_get_camera(__ind, __vind);
	if (__currcam != -1)
	{
		// destroy it so we don't leave it in limbo
		camera_destroy(__currcam);
	}
	
	room_set_camera(__ind, __vind, __newcam);
	
	room_set_viewport(__ind, __vind, __vis, __xport, __yport, __wport, __hport);
	
	return -1;
}

function __init_view()
{
	enum e__VW
	{
		XView,
		YView,
		WView,
		HView,
		Angle,
		HBorder,
		VBorder,
		HSpeed,
		VSpeed,
		Object,
		Visible,
		XPort,
		YPort,
		WPort,
		HPort,
		Camera,
		SurfaceID,
	};
}

function __view_get()
{
	var __prop = argument0;
	var __index = argument1;
	
	var __res = -1;
	
	switch(__prop)
	{
	case e__VW.XView: var __cam = view_get_camera(__index); __res = camera_get_view_x(__cam); break;
	case e__VW.YView: var __cam = view_get_camera(__index); __res = camera_get_view_y(__cam); break;
	case e__VW.WView: var __cam = view_get_camera(__index); __res = camera_get_view_width(__cam); break;
	case e__VW.HView: var __cam = view_get_camera(__index); __res = camera_get_view_height(__cam); break;
	case e__VW.Angle: var __cam = view_get_camera(__index); __res = camera_get_view_angle(__cam); break;
	case e__VW.HBorder: var __cam = view_get_camera(__index); __res = camera_get_view_border_x(__cam); break;
	case e__VW.VBorder: var __cam = view_get_camera(__index); __res = camera_get_view_border_y(__cam); break;
	case e__VW.HSpeed: var __cam = view_get_camera(__index); __res = camera_get_view_speed_x(__cam); break;
	case e__VW.VSpeed: var __cam = view_get_camera(__index); __res = camera_get_view_speed_y(__cam); break;
	case e__VW.Object: var __cam = view_get_camera(__index); __res = camera_get_view_target(__cam); break;
	case e__VW.Visible: __res = view_get_visible(__index); break;
	case e__VW.XPort: __res = view_get_xport(__index); break;
	case e__VW.YPort: __res = view_get_yport(__index); break;
	case e__VW.WPort: __res = view_get_wport(__index); break;
	case e__VW.HPort: __res = view_get_hport(__index); break;
	case e__VW.Camera: __res = view_get_camera(__index); break;
	case e__VW.SurfaceID: __res = view_get_surface_id(__index); break;
	default: break;
	};
	
	return __res;
}

function __view_set()
{
	var __prop = argument0;
	var __index = argument1;
	var __val = argument2;
	
	__view_set_internal(__prop, __index, __val);
	
	var __res = __view_get(__prop, __index);
	
	return __res;
}

function __view_set_internal()
{
	var __prop = argument0;
	var __index = argument1;
	var __val = argument2;
	
	switch(__prop)
	{
	case e__VW.XView: var __cam = view_get_camera(__index); camera_set_view_pos(__cam, __val, camera_get_view_y(__cam)); break;
	case e__VW.YView: var __cam = view_get_camera(__index); camera_set_view_pos(__cam, camera_get_view_x(__cam), __val); break;
	case e__VW.WView: var __cam = view_get_camera(__index); camera_set_view_size(__cam, __val, camera_get_view_height(__cam)); break;
	case e__VW.HView: var __cam = view_get_camera(__index); camera_set_view_size(__cam, camera_get_view_width(__cam), __val); break;
	case e__VW.Angle: var __cam = view_get_camera(__index); camera_set_view_angle(__cam, __val); break;
	case e__VW.HBorder: var __cam = view_get_camera(__index); camera_set_view_border(__cam, __val, camera_get_view_border_y(__cam)); break;
	case e__VW.VBorder: var __cam = view_get_camera(__index); camera_set_view_border(__cam, camera_get_view_border_x(__cam), __val); break;
	case e__VW.HSpeed: var __cam = view_get_camera(__index); camera_set_view_speed(__cam, __val, camera_get_view_speed_y(__cam)); break;
	case e__VW.VSpeed: var __cam = view_get_camera(__index); camera_set_view_speed(__cam, camera_get_view_speed_x(__cam), __val); break;
	case e__VW.Object: var __cam = view_get_camera(__index); camera_set_view_target(__cam, __val); break;
	case e__VW.Visible: __res = view_set_visible(__index, __val); break;
	case e__VW.XPort: __res = view_set_xport(__index, __val); break;
	case e__VW.YPort: __res = view_set_yport(__index, __val); break;
	case e__VW.WPort: __res = view_set_wport(__index, __val); break;
	case e__VW.HPort: __res = view_set_hport(__index, __val); break;
	case e__VW.Camera: __res = view_set_camera(__index, __val); break;
	case e__VW.SurfaceID: __res = view_set_surface_id(__index, __val); break;
	default: break;
	};
	
	return 0;
}

function __view_set_pp()
{
	var __prop = argument0;
	var __index = argument1;
	var __val = argument2;
	
	var __res = __view_get(__prop, __index);
	
	__view_set_internal(__prop, __index, __val);
	
	return __res;
}

#endregion
#region tile

function room_tile_add()
{
	/// @description Add a new tile to a room and return its index.
	/// @param ind The index of the room to set the background of.
	/// @param back The background from which the tile is taken.
	/// @param left The x coordinate of the left side of the tile relative to the background.
	/// @param top The y coordinate of the top side of the tile relative to the background.
	/// @param width The width of the tile.
	/// @param height The height of the tile.
	/// @param x The x coordinate of where to place the tile. 
	/// @param y The y coordinate of where to place the tile.
	/// @param depth The depth of the tile in the room.
	/// @returns {number} resource name for the new tile
	
	var __ind = argument0;
	var __back = argument1;
	var __left = argument2;
	var __top = argument3;
	var __width = argument4;
	var __height = argument5;
	var __x = argument6;
	var __y = argument7;
	var __depth = argument8;
	
	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}
	
	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);
	
	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Don't bother checking names - we'll just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}
	
	if (__layertouse == -1)
	{
		// didn't find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}
	
	// Now create a new tile element and add it to the layer
	var __tile = layer_tile_create(__layertouse, __x, __y, __back, __left, __top, __width, __height);
	
	// Finally, restore our original room target
	layer_set_target_room(__currroom);
	
	return __tile;
}

function room_tile_add_ext()
{
	/// @description Adds a new tile to a given room and sets its properties.
	/// @param ind The index of the room to set the background of.
	/// @param back The background from which the tile is taken.
	/// @param left The x coordinate of the left side of the tile relative to the background.
	/// @param top The y coordinate of the top side of the tile relative to the background.
	/// @param width The width of the tile.
	/// @param height The height of the tile.
	/// @param x The x coordinate of where to place the tile. 
	/// @param y The y coordinate of where to place the tile.
	/// @param depth The depth of the tile in the room.
	/// @param xscale The horizontal scale of the tile. 1=normal size, 0.5=half, 2=double, etc.
	/// @param yscale The vertical scale of the tile. 1=normal size, 0.5=half, 2=double, etc.
	/// @param alpha The alpha (transparency) of the tile. 0=invisible, 1=opaque, 0.5=translucent etc.
	/// @returns {number} resource name for the new tile
	
	var __ind = argument0;
	var __back = argument1;
	var __left = argument2;
	var __top = argument3;
	var __width = argument4;
	var __height = argument5;
	var __x = argument6;
	var __y = argument7;
	var __depth = argument8;
	var __xscale = argument9;
	var __yscale = argument10;
	var __alpha = argument11;
	
	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}
	
	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);
	
	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Don't bother checking names - we'll just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}
	
	if (__layertouse == -1)
	{
		// didn't find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}
	
	// Now create a new tile element and add it to the layer
	var __tile = layer_tile_create(__layertouse, __x, __y, __back, __left, __top, __width, __height);
	layer_tile_xscale(__tile, __xscale);
	layer_tile_yscale(__tile, __yscale);
	layer_tile_alpha(__tile, __alpha);
	
	// Finally, restore our original room target
	layer_set_target_room(__currroom);
	
	return __tile;
}

function room_tile_clear()
{
	/// @description Clears all tiles from a given room.
	/// @param ind The index of the room to clear all tiles from.
	/// @returns 
	
	var __ind = argument0;
	
	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}
	
	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);
	
	// Scan all layers for tile elements and destroy any that we find
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_destroy(__els[__j]);
			}
		}	
	}
	
	
	// Finally, restore our original room target
	layer_set_target_room(__currroom);
}

function tile_add()
{
	/// @description Adds a new tile to the room, allowing customisation of its attributes, and returning its index.
	/// @param background The background asset from which the new tile will be extracted.
	/// @param left The x coordinate of the left of the new tile, relative to the background asset's top left corner.
	/// @param top The y coordinate of the top of the new tile, relative to the background assets top left corner.
	/// @param width The width of the tile.
	/// @param height The height of the tile.
	/// @param x The x position in the room to place the tile.
	/// @param y The y position in the room to place the tile.
	/// @param depth The depth at which to place the tile.
	/// @returns {number} resource name for the new tile
	
	var __back = argument0;
	var __left = argument1;
	var __top = argument2;
	var __width = argument3;
	var __height = argument4;
	var __x = argument5;
	var __y = argument6;
	var __depth = argument7;
	
	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Don't bother checking names - we'll just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}
	
	if (__layertouse == -1)
	{
		// didn't find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}
	
	// Now create a new tile element and add it to the layer
	var __tile = layer_tile_create(__layertouse, __x, __y, __back, __left, __top, __width, __height);
	
	return __tile;
}

function tile_delete()
{
	/// @description Deletes a given tile in the room.
	/// @param index The index of the tile to delete.
	/// @returns
	
	var __index = argument0;
	
	layer_tile_destroy(__index);
}

function tile_exists()
{
	/// @description Checks if a given tile exists in the room.
	/// @param index The index of the tile to check for.
	/// @returns {boolean} whether the tile exists
	
	var __index = argument0;
	
	return layer_tile_exists(__index);
}

function tile_get_alpha()
{
	/// @description Returns the alpha value of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The alpha of the tile
	
	var __index = argument0;
	
	return layer_tile_get_alpha(__index);
}

function tile_get_background()
{
	/// @description Returns the background index a given tile is drawn from.
	/// @param index The index of the tile.
	/// @returns {number} The background index
	
	var __index = argument0;
	
	return layer_tile_get_sprite(__index);
}

function tile_get_blend()
{
	/// @description Returns the blending colour of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The background index
	
	var __index = argument0;
	
	return layer_tile_get_blend(__index);
}

function tile_get_count()
{
	/// @description Returns the total number of tiles in a room.
	/// @returns {number} total number of tiles in room
	
	var __totaltiles = 0;
	
	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				__totaltiles++;
			}
		}	
	}
	
	return __totaltiles;
}

function tile_get_depth()
{
	/// @description Returns the depth of a given tile.
	/// @param index The index of the tile to check.
	/// @returns {number} the depth of the tile
	
	var __index = argument0;
	
	// Should really check if the element ID points to a tile (and not a different sort of element)
	var __layerid = layer_get_element_layer(__index);
	return layer_get_depth(__layerid);
}

function tile_get_height()
{
	/// @description Returns the height of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The height of the tile
	
	var __index = argument0;
	
	var __reg = layer_tile_get_region(__index);
	if (array_length(__reg) == 0)
		return 0;
	
	return __reg[3];
		
}

function tile_get_id()
{
	/// @description Returns the unique id for the given tile index.
	/// @param index The index of the tile.
	/// @returns {number} total number of tiles in room
	
	var __index = argument0;
	
	var __currtile = 0;
	
	// Scan through all layers looking for the specified tile (slow!)
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				if (__currtile == __index)
				{
					return __els[__j];
				}
				
				__currtile++;
			}
		}	
	}
	
	return -1;
}

function tile_get_ids()
{
	/// @description Returns an array containing the unique ID values for all tiles in a room.
	/// @returns {array} IDs of all tiles in the room
	
	var __tiles;
	__tiles[0] = -1;
	var __currtile = 0;
	
	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				__tiles[__currtile] = __els[__j];						
				__currtile++;
			}
		}	
	}
	
	return __tiles;
}

function tile_get_ids_at_depth()
{
	/// @description Returns an array containing the unique ID values for all tiles at a given depth.
	/// @param depth The depth of the tile layer to get the IDs of.
	/// @returns {array} IDs of all tiles of the specified depth in the room
	
	var __depth = argument0;
	
	var __tiles;
	__tiles[0] = -1;
	var __currtile = 0;
	
	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
		
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				__tiles[__currtile] = __els[__j];						
				__currtile++;
			}
		}	
	}
	
	return __tiles;
}

function tile_get_left()
{
	/// @description Returns the left coordinate of a given tile from its background.
	/// @param index The index of the tile.
	/// @returns {number} The width of the tile
	
	var __index = argument0;
	
	var __reg = layer_tile_get_region(__index);
	if (array_length(__reg) == 0)
		return 0;
		
	return __reg[0];
}

function tile_get_top()
{
	/// @description Returns the top coordinate of a given tile from its background.
	/// @param index The index of the tile.
	/// @returns {number} The top of the tile
	
	var __index = argument0;
	
	var __reg = layer_tile_get_region(__index);
	if (array_length(__reg) == 0)
		return 0;
		
	return __reg[1];
}

function tile_get_visible()
{
	/// @description Returns whether a tile is visible or not.
	/// @param index The index of the tile.
	/// @returns {boolean} The visibility of the tile
	
	var __index = argument0;
	
	return layer_tile_get_visible(__index);
}

function tile_get_width()
{
	/// @description Returns the width of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The width of the tile
	
	var __index = argument0;
	
	var __reg = layer_tile_get_region(__index);
	if (array_length(__reg) == 0)
		return 0;
		
	return __reg[2];
}

function tile_get_x()
{
	/// @description Returns the x coordinate of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The x position of the tile
	
	var __index = argument0;
	
	return layer_tile_get_x(__index);
}

function tile_get_xscale()
{
	/// @description Returns the horizontal scaling of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The horizontal scaling of the tile
	
	var __index = argument0;
	
	return layer_tile_get_xscale(__index);
}

function tile_get_y()
{
	/// @description Returns the y coordinate of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The y position of the tile
	
	var __index = argument0;
	
	return layer_tile_get_y(__index);
}

function tile_get_yscale()
{
	/// @description Returns the vertical scaling of a given tile.
	/// @param index The index of the tile.
	/// @returns {number} The vertical scaling of the tile
	
	var __index = argument0;
	
	return layer_tile_get_yscale(__index);
}

function tile_layer_delete()
{
	/// @description Deletes all tiles at the indicated depth layer.
	/// @param depth The depth of tiles which is to be deleted.
	/// @returns 
	
	var __depth = argument0;
	
	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
		
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_destroy(__els[__j]);			
			}
		}	
	}
}
function tile_layer_delete_at()
{
	/// @description Deletes the tile(s) at a given depth and position.
	/// @param depth The depth of a tile to be deleted.
	/// @param x The x position at which to delete a tile.
	/// @param y The y position at which to delete a tile.
	/// @returns 
	
	var __depth = argument0;
	var __x = argument1;
	var __y = argument2;
	
	var __tile_el = tile_layer_find(__depth, __x, __y);
	if (__tile_el != -1)
	{
		layer_tile_destroy(__tile_el);			
	}
}

function tile_layer_depth()
{
	/// @description Moves all tiles at a given depth to a new depth.
	/// @param depth The current depth of the tile layer.
	/// @param newdepth The depth to change the layer to.
	/// @returns 
	
	var __depth = argument0;
	var __newdepth = argument1;
	
	// Scan for a layer with the depth
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	var __layerstomove;
	__layerstomove[0] = -1;
	var __numlayerstomove = 0;
	
	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __layerdepth = layer_get_depth(__layers[__i]);
		
		if (__layerdepth == __depth)
		{
			__layerstomove[__numlayerstomove] = __layers[__i];
			__numlayerstomove++;
		}	
		else if (layer_get_depth(__layers[__i]) == __newdepth)
		{
			// Don't bother checking names - we'll just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}
	
	if (__layertouse == -1)
	{
		// didn't find a layer of the correct depth, so create one
		__layertouse = layer_create(__newdepth);
	}
	
	// Now go through again and move all those tiles of the original depth to the new layer
	// (should we delete layers that become empty?)
	for(__i = 0; __i < __numlayerstomove; __i++)
	{
		var __els = layer_get_all_elements(__layerstomove[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			if (layer_get_element_type(__els[__j]) == layerelementtype_tile)
			{
				layer_element_move(__els[__j], __layertouse);
			}
		}
	}
}

function tile_layer_find()
{
	/// @description Returns the id of a tile at a given depth and position.
	/// @param depth The depth of the tile to be found.
	/// @param x The x position to check.
	/// @param y The y position to check.
	/// @returns 
	
	var __depth = argument0;
	var __x = argument1;
	var __y = argument2;
	
	// Scan through all layers looking for tiles
	// This is going to be slow
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
		
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				var __tileXscale = layer_tile_get_xscale(__els[__j]);
				var __tileYscale = layer_tile_get_yscale(__els[__j]);
				
				// Fast(ish) path with more early-outs
				if ((__tileXscale >= 0) && (__tileYscale >= 0))
				{			
					var __tileX = layer_tile_get_x(__els[__j]);						
					if (__x < __tileX)
						continue;
						
					var __tileY = layer_tile_get_y(__els[__j]);
					if (__y < __tileY)
						continue;
								
					var __tileReg = layer_tile_get_region(__els[__j]);			
					var __tileRight = __tileX + (__tileXscale * __tileReg[2]);
					if (__x >= __tileRight)
						continue;
						
					
					var __tileBottom = __tileY + (__tileYscale * __tileReg[3]);
					if (__y >= __tileBottom)
						continue;
					
					// Passed all the tests so return this tile
					return __els[__j];
				}
				else
				{
					var __tileReg = layer_tile_get_region(__els[__j]);
					var __minx = layer_tile_get_x(__els[__j]);
					var __maxx = __minx + (__tileXscale * __tileReg[2]);
					if (__minx > __maxx)
					{
						var __temp = __minx;
						__minx = __maxx;
						__maxx = __temp;
					}
					
					if (__x < __minx)
						continue;
						
					if (__x >= __maxx)
						continue;
						
					var __miny = layer_tile_get_y(__els[__j]);
					var __maxy = __miny + (__tileYscale * __tileReg[3]);
					if (__miny > __maxy)
					{
						var __temp = __miny;
						__miny = __maxy;
						__maxy = __temp;
					}
					
					if (__y < __miny)
						continue;
						
					if (__y >= __maxy)
						continue;
						
					// Passed all the tests so return this tile
					return __els[__j];
					
				}
			}
		}	
	}
	
	return -1;
}

function tile_layer_hide()
{
	/// @description Hides all tiles at the indicated depth layer.
	/// @param depth The depth of tiles which is to be hidden.
	/// @returns 
	
	var __depth = argument0;
	
	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
		
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_visible(__els[__j],false);			
			}
		}	
	}
}

function tile_layer_shift()
{
	/// @description Shifts all tiles at the indicated depth layer by a given amount.
	/// @param depth The depth of tiles which is to be shifted.
	/// @param x The amount to shift over the x-axis.
	/// @param y The amount to shift over the y-axis.
	/// @returns 
	
	var __depth = argument0;
	var __x = argument1;
	var __y = argument2;
	
	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
		
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_x(__els[__j], layer_tile_get_x(__els[__j]) + __x);
				layer_tile_y(__els[__j], layer_tile_get_y(__els[__j]) + __y);			
			}
		}	
	}
}

function tile_layer_show()
{
	/// @description Shows all tiles at the indicated depth layer.
	/// @param depth The depth of tiles which is to be shown.
	/// @returns 
	
	var __depth = argument0;
	
	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
		
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length(__els);
		
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_visible(__els[__j],true);			
			}
		}	
	}
}

function tile_set_alpha()
{
	/// @description Sets a tile's alpha (transparency).
	/// @param index The index of the tile.
	/// @param alpha The transparency of the tile.
	/// @returns 
	
	var __index = argument0;
	var __alpha = argument1;
	
	return layer_tile_alpha(__index, __alpha);
}

function tile_set_background()
{
	/// @description Sets the background for a tile to be drawn from.
	/// @param index The index of the tile.
	/// @param background The index of the background to take the tile from.
	/// @returns 
	
	var __index = argument0;
	var __background = argument1;
	
	return layer_tile_change(__index, __background);
}

function tile_set_blend()
{
	/// @description Sets a tile's blending.
	/// @param index The index of the tile.
	/// @param colour The colour to blend the tile with.
	/// @returns 
	
	var __index = argument0;
	var __colour = argument1;
	
	return layer_tile_blend(__index, __colour);
}

function tile_set_depth()
{
	/// @description Sets a tile's depth.
	/// @param index The index of the tile to set.
	/// @param depth The depth of the tile.
	/// @returns
	
	var __index = argument0;
	var __depth = argument1;
	
	// Should really check if the element ID points to a tile (and not a different sort of element)
	var __layerid = layer_get_element_layer(__index);
	if (__layerid == -1)
		return -1;	// not found
		
	var __currdepth = layer_get_depth(__layerid);
	if (__currdepth == __depth)
		return -1;	// depth already correct
		
	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length(__layers);
	
	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Don't bother checking names - we'll just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}
	
	if (__layertouse == -1)
	{
		// didn't find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}
	
	// Now move the tile from it's old layer to the new one
	layer_element_move(__index, __layertouse);
	
	return layer_get_depth(__layerid);

}

function tile_set_position()
{
	/// @description Sets the position of a given tile.
	/// @param index The index of the tile.
	/// @param x The tile's new x position.
	/// @param y The tile's new y position.
	/// @returns 
	
	var __index = argument0;
	var __x = argument1;
	var __y = argument2;
	
	layer_tile_x(__index, __x);
	layer_tile_y(__index, __y);
}

function tile_set_region()
{
	/// @description Sets the region of its background a tile is taken from.
	/// @param index The index of the tile.
	/// @param left The tile's left position relative to the background's top left corner.
	/// @param top The tile's top position relative to the background's top left corner.
	/// @param width The tile's width.
	/// @param height The tile's height.
	/// @returns 
	
	var __index = argument0;
	var __left = argument1;
	var __top = argument2;
	var __width = argument3;
	var __height = argument4;
	
	layer_tile_region(__index, __left, __top, __width, __height);
}

function tile_set_scale()
{
	/// @description Sets a tile's horizontal and vertical scaling.
	/// @param index The index of the tile.
	/// @param xscale The tile's horizontal scale.
	/// @param yscale The tile's vertical scale.
	/// @returns 
	
	var __index = argument0;
	var __xscale = argument1;
	var __yscale = argument2;
	
	layer_tile_xscale(__index, __xscale);
	layer_tile_yscale(__index, __yscale);
}

function tile_set_visible()
{
	/// @description Sets a tile's visibility.
	/// @param index The index of the tile.
	/// @param visible The visibility of the tile. true=visible, false=invisible.
	/// @returns 
	
	var __index = argument0;
	var __visible = argument1;
	
	layer_tile_visible(__index, __visible);
}

#endregion
#region texture

function texture_set_blending()
{
	var __dummy = argument0;
	
	show_debug_message("texture_set_blending() currently not supported");
}

function texture_set_interpolation()
{
	gpu_set_texfilter(argument0);
}

function texture_set_interpolation_ext()
{
	gpu_set_texfilter_ext(argument0, argument1);
}

function texture_set_repeat()
{
	gpu_set_texrepeat( argument0 );
}

function texture_set_repeat_ext()
{
	gpu_set_texrepeat_ext( argument0, argument1 );
}

#endregion
#region sound

function sound_add()
{
	/// @description (Deprecated) add a sound resource
	/// @param fname	The filename of the sound to add.
	/// @param kind		The kind of sound it should be added as (legacy Feature) 0=normal, 1=background, 2=3D, 3=multimedia player, for things like MP3s).
	/// @param preload	Whether the sound should preload into memory immediately (true) or not (false) (legacy Feature) .
	show_debug_message( "sound_add is not supported");
	return -1;
}

function sound_delete()
{
	/// @description Deletes the indicated sound to free it from game memory. 
	/// @param index	sound index
	audio_delete(argument0);
	

}

function sound_discard()
{
	/// @description sound_discard - deprecated function
	/// @param index	sound index
	show_debug_message( "sound_discard is a deprecated function" );
	return 0;
}

function sound_exists()
{
	/// @description Checks whether the given sound exists. 
	/// @param index	sound index
	/// @returns {boolean} true if sound exists, false otherwise
	return audio_exists(argument0);
	

}

function sound_fade()
{
	/// @description Fade a sound in or out over a given time.
	/// @param index	sound index
	/// @param volume	The final volume from 0 to 1.
	/// @param time		The length for the change in gain in milliseconds. 
	audio_sound_gain( argument0, argument1, argument2 );
}

function sound_get_kind()
{
	/// @description sound_get_kind - deprecated function
	/// @param index	sound index
	show_debug_message( "sound_get_kind - deprecated function");
	return 0;

}

function sound_get_name()
{
	/// @description Returns the resource name of the given sound.
	/// @param index	sound index
	/// @returns {string} resource name for the given sound
	return audio_get_name( argument0 );

}

function sound_get_preload()
{
	/// @description sound_get_preload - deprecated function
	/// @param index	sound index
	show_debug_message( "sound_get_preload - deprecated function");
	return 0;

}

function sound_global_volume()
{
	/// @description Sets the volume of all sounds
	/// @param value	The new global volume from 0 to 1.
	audio_master_gain(argument0)
	

}

function sound_isplaying()
{
	/// @description Checks to see if a given sound is playing.
	/// @param index	sound index
	/// @return {boolean} 
	return audio_is_playing( argument0 );

}

function sound_loop()
{
	// ------------------------------------------------------------
	/// @description Loops the indicated sound
	/// @param index The index of the sound to loop
	
	audio_play_sound( argument0, 10, true );

}

function sound_name()
{
	/// @description sound_name - deprecated function
	/// @param index	sound index
	return audio_get_name( argument0 );

}

function sound_play()
{
	// ------------------------------------------------------------
	/// @description Plays the indicated sound once.
	/// @param index The index of the sound to play
	
	audio_play_sound( argument0, 10, false );

}

function sound_replace()
{
	/// @description (Deprecated) Replaces an existing sound with one from a given filename
	/// @param index 	The index of the sound to be replace.
	/// @param fname	The filename of the sound to add.
	/// @param kind		The kind of sound it should be added as (legacy Feature) 0=normal, 1=background, 2=3D, 3=multimedia player, for things like MP3s).
	/// @param preload	Whether the sound should preload into memory immediately (true) or not (false) (legacy Feature) .
	show_debug_message( "sound_replace is not supported");
	return false;
}

function sound_restore()
{
	/// @description sound_restore - deprecated function
	/// @param index	sound index
	show_debug_message( "sound_restore is a deprecated function" );
	return 0;
}

function sound_stop()
{
	// ------------------------------------------------------------
	/// @description Stops a given sound.
	/// @param index The index of the sound to stop
	
	audio_stop_sound( argument0 );

}

function sound_stop_all()
{
	// ------------------------------------------------------------
	/// @description Stops a given sound.
	audio_stop_all();
	

}

function sound_volume()
{
	/// @description Sets the volume of a given sound.
	/// @param index 	The index of the sound to change the volume of.
	/// @param value	The new global volume from 0 to 1.
	audio_sound_gain( argument0, argument1, 0);
}

#endregion
#region object

function object_get_depth()
{
	/// @description Returns the depth of the specified object.
	/// @param {Number} obj The index of the object to check
	/// @return {Number} depth of the object
	
	var objID = argument0;
	var ret = 0;
	if (objID >= 0) && (objID < array_length(global.__objectID2Depth)) {
		ret = global.__objectID2Depth[objID];
	} // end if
	return ret;
}

function object_set_depth()
{
	/// @description Sets the depth of the given object.
	/// @param {Number} index The index of the object to change
	/// @param {Number} depth The new depth of the object
	var objID = argument0;
	if (object_exists(objID)) {
		with( objID ) {
			global.__objectID2Depth[id] = argument1;
		} // end with
	} // end if

}

#endregion
#region joystick

function joystick_axes()
{
	/// @description Returns the number of axes the joystick has.
	/// @param id	the id of the joystick (1 or 2)
	var jid=__joystick_2_gamepad(argument0);
	return gamepad_axis_count(jid);
}

function joystick_buttons()
{
	/// @description Returns the number of buttons the joystick has.
	/// @param id	the id of the joystick (1 or 2)
	
	var jid=__joystick_2_gamepad(argument0);
	return gamepad_button_count(jid);
}

function joystick_check_button()
{
	/// @description Checks to see if a joystick button has been pressed.
	/// @param id	the id of the joystick (1 or 2)
	/// @param numb The number of the button to check (from 1 to 32).
	/// @return {Boolean} true if selected button pressed / false otherwise
	var jid=__joystick_2_gamepad(argument0);
	
	var button = 0;
	switch( argument1 )
	{
	case 0:	button = gp_face1; break;
	case 1:	button = gp_face2; break;
	case 2:	button = gp_face3; break;
	case 3:	button = gp_face4; break;
	case 4:	button = gp_shoulderl; break;
	case 5:	button = gp_shoulderlb; break;
	case 6:	button = gp_shoulderr; break;
	case 7:	button = gp_shoulderrb; break;
	case 8:	button = gp_select; break;
	case 9:	button = gp_start; break;
	case 10: button = gp_stickl; break;
	case 11: button = gp_stickr; break;
	default:
		button = argument1;
		break;
	}
	
	return (gamepad_button_value(jid, button) != 0);
}

function joystick_direction()
{
	/// @description Checks to see if a joystick button has been pressed.
	/// @param id	the id of the joystick (1 or 2)
	/// @return  {Number} virtual key code for the numberpad buttons depending on direction being pressed by the joystick/gamepad with the given id
	var jid=__joystick_2_gamepad(argument0);
	
	var haxis = gamepad_axis_value( jid, gp_axislh );
	var vaxis = gamepad_axis_value( jid, gp_axislv );
	
	var dir = 0;
	if (vaxis < -0.3)
		dir = 6;
	else
	if (vaxis > 0.3)
		dir = 0;
	else
		dir = 3;
	
	if (haxis < -0.3)
		dir += 1;
	else
	if (haxis > 0.3)
		dir += 3;
	else 
		dir += 2;
	
	return vk_numpad0+dir;
}

function joystick_exists()
{
	/// @description Checks for a joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return  {Boolean} true if a joystick/gamepad with the given id is connected or false if it is not
	
	var jid=__joystick_2_gamepad(argument0);
	return gamepad_is_connected(jid);
}

function joystick_has_pov()
{
	/// @description Checks the point of view capabilities of the joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return  {Boolean} true if the joystick/gamepad with the given id has point of view capabilities or false if it does not
	
	return true;

}

function joystick_name()
{
	/// @description Returns the name of the joystick.
	/// @param id	the id of the joystick (1 or 2)
	
	var jid=__joystick_2_gamepad(argument0);
	return gamepad_get_description(jid);
}

function joystick_pov()
{
	/// @description Returns the name of the joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the point-of view position of the joystick/gamepad with the given id. This is an angle between 0 and 360 degrees, where 0 is forwards, 90 to the right, 180 backwards and 270 to the left
	
	var jid=__joystick_2_gamepad(argument0);
	
	var mask = 0;
	mask |= (gamepad_button_value( jid, gp_padu) > 0) ? 1 : 0;
	mask |= (gamepad_button_value( jid, gp_padr) > 0) ? 2 : 0;
	mask |= (gamepad_button_value( jid, gp_padd) > 0) ? 4 : 0;
	mask |= (gamepad_button_value( jid, gp_padl) > 0) ? 8 : 0;
	
	return global.__jstick_povangle[mask];
	

}

function joystick_process_events()
{
	/// @description Process joystick events (since the Runner no longer processes them directly)
	if (argument_count > 0) and (argument[0] > 0) return;
	
	// check to see if joystick 1 exists and process its events
	if (joystick_exists(1)) {
	
		var xaxis = joystick_xpos(1);
		if (xaxis < -0.3) event_perform(ev_mouse, ev_joystick1_left );
		if (xaxis >  0.3) event_perform(ev_mouse, ev_joystick1_right );
		
		var yaxis = joystick_ypos(1);
		if (yaxis < -0.3) event_perform(ev_mouse, ev_joystick1_up );
		if (yaxis >  0.3) event_perform(ev_mouse, ev_joystick1_down );
	
		if (joystick_check_button(1, 0)) event_perform(ev_mouse, ev_joystick1_button1 );
		if (joystick_check_button(1, 1)) event_perform(ev_mouse, ev_joystick1_button2 );
		if (joystick_check_button(1, 2)) event_perform(ev_mouse, ev_joystick1_button3 );
		if (joystick_check_button(1, 3)) event_perform(ev_mouse, ev_joystick1_button4 );
		if (joystick_check_button(1, 4)) event_perform(ev_mouse, ev_joystick1_button5 );
		if (joystick_check_button(1, 5)) event_perform(ev_mouse, ev_joystick1_button6 );
		if (joystick_check_button(1, 6)) event_perform(ev_mouse, ev_joystick1_button7 );
		if (joystick_check_button(1, 7)) event_perform(ev_mouse, ev_joystick1_button8 );
	}
	
	// check to see if joystick 1 exists and process its events
	if (joystick_exists(2)) {
	
		var xaxis = joystick_xpos(2);
		if (xaxis < -0.3) event_perform(ev_mouse, ev_joystick1_left );
		if (xaxis >  0.3) event_perform(ev_mouse, ev_joystick1_right );
		
		var yaxis = joystick_ypos(2);
		if (yaxis < -0.3) event_perform(ev_mouse, ev_joystick1_up );
		if (yaxis >  0.3) event_perform(ev_mouse, ev_joystick1_down );
	
		if (joystick_check_button(2, 0)) event_perform(ev_mouse, ev_joystick1_button1 );
		if (joystick_check_button(2, 1)) event_perform(ev_mouse, ev_joystick1_button2 );
		if (joystick_check_button(2, 2)) event_perform(ev_mouse, ev_joystick1_button3 );
		if (joystick_check_button(2, 3)) event_perform(ev_mouse, ev_joystick1_button4 );
		if (joystick_check_button(2, 4)) event_perform(ev_mouse, ev_joystick1_button5 );
		if (joystick_check_button(2, 5)) event_perform(ev_mouse, ev_joystick1_button6 );
		if (joystick_check_button(2, 6)) event_perform(ev_mouse, ev_joystick1_button7 );
		if (joystick_check_button(2, 7)) event_perform(ev_mouse, ev_joystick1_button8 );
	}
}

function joystick_rpos()
{
	/// @description Returns the position of the r-axis of joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the position of the r-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
	
	var jid=__joystick_2_gamepad(argument0);
	
	return gamepad_axis_value( jid, 3);
}

function joystick_upos()
{
	/// @description Returns the position of the u-axis of joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the position of the u-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
	
	var jid=__joystick_2_gamepad(argument0);
	
	return gamepad_axis_value( jid, 4);
}

function joystick_vpos()
{
	/// @description Returns the position of the v-axis of joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the position of the v-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
	
	var jid=__joystick_2_gamepad(argument0);
	
	return gamepad_axis_value( jid, 5);
}

function joystick_xpos()
{
	/// @description Returns the position of the x-axis of joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the position of the x-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
	
	var jid=__joystick_2_gamepad(argument0);
	
	return gamepad_axis_value( jid, 0);
}

function joystick_ypos()
{
	/// @description Returns the position of the yx-axis of joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the position of the y-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
	
	
	var jid=__joystick_2_gamepad(argument0);
	
	return gamepad_axis_value( jid, 1);
}

function joystick_zpos()
{
	/// @description Returns the position of the z-axis of joystick.
	/// @param id	the id of the joystick (1 or 2)
	/// @return {Number} the position of the z-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
	
	var jid=__joystick_2_gamepad(argument0);
	
	return gamepad_axis_value( jid, 2);
}

function __init_joystick()
{
	gml_pragma( "global", "__init_joystick();");
	//#macro __JOYSTICK_2_GAMEPAD	(argument0 == 2) ? global.__jstick_pad2 : global.__jstick_pad1
	global.__jstick_pad1=4;
	global.__jstick_pad2=5;
	global.__jstick_povangle = [
									-1,		// 0 - centered
									0,		// 1 - up
									90,		// 2 - right
									45,		// 3 - up and right
									180,	// 4 - down
									-1,		// 5 - down and up (invalid)
									135,	// 6 - down and right
									-1,		// 7 - down, up and right (invalid)
									270,	// 8 - left
									315,	// 9 - left and up
									-1,		// 10 - left and right (invalid)
									-1,		// 11 - left, up and right (invalid)
									225,	// 12 - left and down
									-1,		// 13 - left, down and up (invalid)
									-1,		// 14 - left, down and right (invalid)
									-1,		// 16 - left, right, up and down (invalid)
								];
	
	
	// reference the function to ensure that it is brought in
	joystick_process_events(true);
}

function __joystick_2_gamepad()
{
	if (argument0 == 2) 
		return global.__jstick_pad2;
	else
		return global.__jstick_pad1;

}

#endregion
#region instance

function instance_create()
{
	/// @description Creates an instance of a given object at a given position.
	/// @param x The x position the object will be created at.
	/// @param y The y position the object will be created at.
	/// @param obj The object to create an instance of.
	var myDepth = object_get_depth( argument2 );
	return instance_create_depth( argument0, argument1, myDepth, argument2 );

}

#endregion
#region draw

function draw_enable_alphablend()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	gpu_set_blendenable( argument0 );
}

function draw_get_alpha_test()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	return gpu_get_alphatestenable();
}

function draw_get_alpha_test_ref_value()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	return gpu_get_alphatestref();
}

function draw_set_alpha_test()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	gpu_set_alphatestenable( argument0 );
}

function draw_set_alpha_test_ref_value()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	gpu_set_alphatestref( argument0 );
}

function draw_set_blend_mode()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	gpu_set_blendmode( argument0 );
}

function draw_set_blend_mode_ext()
{
	/// @description Sets an extended blend mode for drawing.
	/// @param src Source blend mode
	/// @param dest Destination blend mode
	gpu_set_blendmode_ext( argument0, argument1 );
}

function draw_set_color_write_enable()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	gpu_set_colorwriteenable( argument0, argument1, argument2, argument3 );
}

function draw_set_colour_write_enable()
{
	/// @description Sets the blend mode for drawing.
	/// @param mode The blend mode constant to set to 
	gpu_set_colorwriteenable( argument0, argument1, argument2, argument3 );
}

#endregion
#region d3d

function d3d_draw_block()
{
	/// @description Draws a simple 3D block.
	/// @param x1 The initial x coordinate of the block. 
	/// @param y1 The initial y coordinate of the block.
	/// @param z1 The initial z coordinate of the block.
	/// @param x2 The opposite x coordinate of the block.
	/// @param y2 The opposite y coordinate of the block.
	/// @param z2 The opposite z coordinate of the block.
	/// @param tex The id of the texture to use (-1 for no texture)
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @returns 
	
	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	
	
	d3d_primitive_begin_texture(pr_trianglelist, __tex);
	
	
	d3d_vertex_normal_texture(__x1, __y1, __z1, 0, 0, -1, 0, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z1, 0, 0, -1, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);
	
	d3d_vertex_normal_texture(__x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z1, 0, 0, -1, __hrepeat, 0);
	d3d_vertex_normal_texture(__x1, __y1, __z1, 0, 0, -1, 0, 0);
	
	
	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, 0, 1, 0, 0);
	d3d_vertex_normal_texture(__x2, __y1, __z2, 0, 0, 1, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);
	
	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y2, __z2, 0, 0, 1, 0, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, 0, 1, 0, 0);
	
	
	d3d_vertex_normal_texture(__x1, __y2, __z1, 0, 1, 0, 0, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z2, 0, 1, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);
	
	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z1, 0, 1, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z1, 0, 1, 0, 0, 0);
	
	
	d3d_vertex_normal_texture(__x2, __y2, __z1, 1, 0, 0, 0, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z2, 1, 0, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);
	
	d3d_vertex_normal_texture(__x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z1, 1, 0, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z1, 1, 0, 0, 0, 0);
	
	
	d3d_vertex_normal_texture(__x2, __y1, __z1, 0, -1, 0, 0, 0);
	d3d_vertex_normal_texture(__x2, __y1, __z2, 0, -1, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);
	
	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z1, 0, -1, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y1, __z1, 0, -1, 0, 0, 0);
	
	
	d3d_vertex_normal_texture(__x1, __y1, __z1, -1, 0, 0, 0, 0);
	d3d_vertex_normal_texture(__x1, __y1, __z2, -1, 0, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);
	
	d3d_vertex_normal_texture(__x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y2, __z1, -1, 0, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x1, __y1, __z1, -1, 0, 0, 0, 0);
	
	d3d_primitive_end();
	
	gpu_set_texrepeat(__oldrep);
}

function d3d_draw_cone()
{
	/// @description Draws a simple 3D cone.
	/// @param x1 The initial x coordinate of the cone.
	/// @param y1 The initial y coordinate of the cone.
	/// @param z1 The initial z coordinate of the cone.
	/// @param x2 The opposite x coordinate of the cone.
	/// @param y2 The opposite y coordinate of the cone. 
	/// @param z2 The opposite z coordinate of the cone.
	/// @param tex The id of the texture to use (-1 for no texture)
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @param closed Sets whether to close (true) the bottom of the cone or not (false).
	/// @param steps How many steps are used to make the cone "round" (typically 24)
	/// @returns 
	
	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;
	
	if (__steps < 3)
	{
		__steps = 3;
	}
	
	if (__steps > 128)
	{
		__steps = 128;
	}
	
	// Create sin and cos tables
	var __cc;
	var __ss;
	
	__cc[__steps] = 0;
	__ss[__steps] = 0;
	
	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}
	
	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	
	
	d3d_primitive_begin_texture(pr_trianglestrip, __tex);
	
	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_vertex_normal_texture(__mx, __my, __z2, 0, 0, 1, __hrepeat * __i / __steps, __vrepeat);
		d3d_vertex_normal_texture(__mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}
	
	d3d_primitive_end();
	
	if (__closed == true)
	{
		d3d_primitive_begin_texture(pr_trianglefan, __tex);
		d3d_vertex_normal_texture(__mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_vertex_normal_texture(__mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_primitive_end();
	}
	
	gpu_set_texrepeat(__oldrep);
}

function d3d_draw_cylinder()
{
	/// @description Draws a simple 3D cylinder.
	/// @param x1 The initial x coordinate of the cylinder.
	/// @param y1 The initial y coordinate of the cylinder.
	/// @param z1 The initial z coordinate of the cylinder.
	/// @param x2 The opposite x coordinate of the cylinder.
	/// @param y2 The opposite y coordinate of the cylinder. 
	/// @param z2 The opposite z coordinate of the cylinder.
	/// @param tex The id of the texture to use (-1 for no texture)
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @param closed Sets whether to close (true) the bottom and top of the cylinder or not (false).
	/// @param steps How many steps are used to make the cylinder "round" (typically 24)
	/// @returns 
	
	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;
	
	if (__steps < 3)
	{
		__steps = 3;
	}
	
	if (__steps > 128)
	{
		__steps = 128;
	}
	
	// Create sin and cos tables
	var __cc;
	var __ss;
	
	__cc[__steps] = 0;
	__ss[__steps] = 0;
	
	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}
	
	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	
	
	if (__closed == true)
	{
		d3d_primitive_begin_texture(pr_trianglefan, __tex);
		d3d_vertex_normal_texture(__mx, __my, __z2, 0, 0, 1, 0, __vrepeat);
		for(__i = 0; __i <= __steps; __i++)
		{
			d3d_vertex_normal_texture(__mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z2, 0, 0, 1, 0, __vrepeat);		
		}
		d3d_primitive_end();
	}
	
	d3d_primitive_begin_texture(pr_trianglestrip, __tex);
	
	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_vertex_normal_texture(__mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z2, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, __vrepeat);
		d3d_vertex_normal_texture(__mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}
	
	d3d_primitive_end();
	
	if (__closed == true)
	{
		d3d_primitive_begin_texture(pr_trianglefan, __tex);
		d3d_vertex_normal_texture(__mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_vertex_normal_texture(__mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_primitive_end();
	}
	
	gpu_set_texrepeat(__oldrep);
}

function d3d_draw_ellipsoid()
{
	/// @description Draws a simple 3D ellipsoid.
	/// @param x1 The initial x coordinate of the ellipsoid.
	/// @param y1 The initial y coordinate of the ellipsoid.
	/// @param z1 The initial z coordinate of the ellipsoid.
	/// @param x2 The opposite x coordinate of the ellipsoid.
	/// @param y2 The opposite y coordinate of the ellipsoid. 
	/// @param z2 The opposite z coordinate of the ellipsoid.
	/// @param tex The id of the texture to use (-1 for no texture)
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @param steps How many steps are used to make the ellipsoid "round" (typically 24)
	/// @returns 
	
	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __steps = argument9;
	
	if (__steps < 3)
	{
		__steps = 3;
	}
	
	if (__steps > 128)
	{
		__steps = 128;
	}
	
	// Create sin and cos tables
	var __cc;
	var __ss;
	
	__cc[__steps] = 0;
	__ss[__steps] = 0;
	
	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}
	
	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __mz = (__z2 + __z1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	var __rz = (__z2 - __z1) / 2;
	
	var __rows = floor((__steps + 1) / 2);
	var __j;
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	
	
	for(__j = 0; __j <= (__rows - 1); __j++)
	{
		var __row1rad = (__j*pi)/__rows;
		var __row2rad = ((__j+1)*pi)/__rows;
		var __rh1 = cos(__row1rad);
		var __rd1 = sin(__row1rad);
		var __rh2 = cos(__row2rad);
		var __rd2 = sin(__row2rad);
		
		d3d_primitive_begin_texture(pr_trianglestrip, __tex);
		
		for(__i = 0; __i <= __steps; __i++)
		{
			// Some common subexpressions here that could be eliminated
			d3d_vertex_normal_texture(__mx+__rx*__rd1*__cc[__i], __my+__ry*__rd1*__ss[__i], __mz+__rz*__rh1,__rd1*__cc[__i], __rd1*__ss[__i], __rh1, __hrepeat*__i/__steps, __j*__vrepeat/__rows);
			d3d_vertex_normal_texture(__mx+__rx*__rd2*__cc[__i], __my+__ry*__rd2*__ss[__i], __mz+__rz*__rh2,__rd2*__cc[__i], __rd2*__ss[__i], __rh2, __hrepeat*__i/__steps, (__j+1)*__vrepeat/__rows);
		}
		
		d3d_primitive_end();
	}
	
	gpu_set_texrepeat(__oldrep);
}

function d3d_draw_floor()
{
	/// @description Draws a simple 3D floor.
	/// @param x1 The initial x coordinate of the floor.
	/// @param y1 The initial y coordinate of the floor.
	/// @param z1 The initial z coordinate of the floor.
	/// @param x2 The opposite x coordinate of the floor.
	/// @param y2 The opposite y coordinate of the floor. 
	/// @param z2 The opposite z coordinate of the floor.
	/// @param tex The id of the texture to use (-1 for no texture)
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @returns 
	
	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	
	var __xdiff = __x2 - __x1;
	var __zdiff = __z2 - __z1;
	
	var __lsquared = (__xdiff * __xdiff) + (__zdiff * __zdiff);
	if (__lsquared == 0)
		return 0;
		
	var __l = sqrt(__lsquared);
	
	var __nx = -__zdiff / __l;
	var __nz = __xdiff / __l;
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)
	
	d3d_primitive_begin_texture(pr_trianglefan, __tex);
	
	d3d_vertex_normal_texture(__x1, __y1, __z1, __nx, 0, __nz, 0, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z1, __nx, 0, __nz, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z2, __nx, 0, __nz, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z2, __nx, 0, __nz, __hrepeat, 0);
	
	d3d_primitive_end();
	
	gpu_set_texrepeat(__oldrep);
}

function d3d_draw_wall()
{
	/// @description Draws a simple 3D vertical wall.
	/// @param x1 The initial x coordinate of the wall.
	/// @param y1 The initial y coordinate of the wall.
	/// @param z1 The initial z coordinate of the wall.
	/// @param x2 The opposite x coordinate of the wall.
	/// @param y2 The opposite y coordinate of the wall. 
	/// @param z2 The opposite z coordinate of the wall.
	/// @param tex The id of the texture to use (-1 for no texture)
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @returns 
	
	//var ret = global.__d3d;
	//global.__d3d = false;
	//return ret;
	
	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	
	var __xdiff = __x2 - __x1;
	var __ydiff = __y2 - __y1;
	
	var __lsquared = (__xdiff * __xdiff) + (__ydiff * __ydiff);
	if (__lsquared == 0)
		return 0;
		
	var __l = sqrt(__lsquared);
	
	var __nx = __ydiff / __l;
	var __ny = -__xdiff / __l;
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	
	
	d3d_primitive_begin_texture(pr_trianglefan, __tex);
	
	d3d_vertex_normal_texture(__x1, __y1, __z1, __nx, __ny, 0, 0, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z1, __nx, __ny, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z2, __nx, __ny, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z2, __nx, __ny, 0, 0, __vrepeat);
	
	d3d_primitive_end();
	
	gpu_set_texrepeat(__oldrep);
}

function d3d_end()
{
	/// @description d3d - disable 3d
	/// @param enable true if enabled, false if disabled
	var ret = global.__d3d;
	global.__d3d = false;
	gpu_set_ztestenable(false);
	gpu_set_zwriteenable(false);
	return ret;

}

function d3d_light_define_ambient()
{
	/// @description d3d - set the ambient colour
	/// @param colour colour for the ambient light
	draw_light_define_ambient( argument0 );
	

}

function d3d_light_define_direction()
{
	/// @description d3d - set the direction of a specific light
	/// @param index	number of light 
	/// @param x	x component
	/// @param y	y component
	/// @param z	z component
	/// @param col	colour for this light
	draw_light_define_direction( argument0, argument1, argument2, argument3, argument4 );
	

}

function d3d_light_define_point()
{
	/// @description d3d - set the point and of a specific light
	/// @param index	number of light 
	/// @param x	x component
	/// @param y	y component
	/// @param z	z component
	/// @param range	range for this light
	/// @param col	colour for this light
	draw_light_define_point( argument0, argument1, argument2, argument3, argument4, argument5 );
	

}

function d3d_light_enable()
{
	/// @description d3d - enable lighting
	/// @param index	number of light 
	/// @param enable	true if enabled, false if disabled
	draw_light_enable( argument0, argument1 );

}

function d3d_model_block()
{
	/// @description Adds a block shape to the model.
	/// @param ind The model index to add the block to.
	/// @param x1 The initial x coordinate of the block. 
	/// @param y1 The initial y coordinate of the block.
	/// @param z1 The initial z coordinate of the block.
	/// @param x2 The opposite x coordinate of the block.
	/// @param y2 The opposite y coordinate of the block.
	/// @param z2 The opposite z coordinate of the block.
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @returns 
	
	var __ind = argument0
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
		
	
	d3d_model_primitive_begin(__ind, pr_trianglelist);
	
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, 0, 0, -1, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, 0, 0, -1, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);
	
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 0, 0, -1, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, 0, 0, -1, 0, 0);
	
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, 0, 1, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 0, 0, 1, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);
	
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, 0, 0, 1, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, 0, 1, 0, 0);
	
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, 0, 1, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, 0, 1, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);
	
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 0, 1, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, 0, 1, 0, 0, 0);
	
	
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 1, 0, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 1, 0, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);
	
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 1, 0, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 1, 0, 0, 0, 0);
	
	
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 0, -1, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 0, -1, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, 0, -1, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 0, -1, 0, 0, 0);
	
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, -1, 0, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, -1, 0, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, -1, 0, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, -1, 0, 0, 0, 0);
	
	d3d_model_primitive_end(__ind);
}

function d3d_model_clear()
{
	/// @description Clears the model with the given index, removing all its primitives.
	/// @param ind The index of the model to be cleared.
	/// @returns 
	
	var __m = argument0;
	
	// Scrub any buffers we have created
	if (__m[e__YYM.PointB] != undefined)
	{
		buffer_delete(__m[e__YYM.PointB]);
		__m[e__YYM.PointB] = undefined;
	}
	
	if (__m[e__YYM.LineB] != undefined)
	{
		buffer_delete(__m[e__YYM.LineB]);
		__m[e__YYM.LineB] = undefined;
	}
	
	if (__m[e__YYM.TriB] != undefined)
	{
		buffer_delete(__m[e__YYM.TriB]);
		__m[e__YYM.TriB] = undefined;
	}
	
	if (__m[e__YYM.PointUVB] != undefined)
	{
		buffer_delete(__m[e__YYM.PointUVB]);
		__m[e__YYM.PointUVB] = undefined;
	}
	
	if (__m[e__YYM.LineUVB] != undefined)
	{
		buffer_delete(__m[e__YYM.LineUVB]);
		__m[e__YYM.LineUVB] = undefined;
	}
	
	if (__m[e__YYM.TriUVB] != undefined)
	{
		buffer_delete(__m[e__YYM.TriUVB]);
		__m[e__YYM.TriUVB] = undefined;
	}
	
	// Scrub any vertex buffers we have created
	if (__m[e__YYM.PointVB] != undefined)
	{
		vertex_delete_buffer(__m[e__YYM.PointVB]);
		__m[e__YYM.PointVB] = undefined;
	}
	
	if (__m[e__YYM.LineVB] != undefined)
	{
		vertex_delete_buffer(__m[e__YYM.LineVB]);
		__m[e__YYM.LineVB] = undefined;
	}
	
	if (__m[e__YYM.TriVB] != undefined)
	{
		vertex_delete_buffer(__m[e__YYM.TriVB]);
		__m[e__YYM.TriVB] = undefined;
	}
	
	// Set num verts to zero
	__m[e__YYM.NumVerts] = 0;
	__m[e__YYM.NumPointCols] = 0;
	__m[e__YYM.NumLineCols] = 0;
	__m[e__YYM.NumTriCols] = 0;
}

function d3d_model_cone()
{
	/// @description Adds a cone shape to the model.
	/// @param ind The model index to add the cone to.
	/// @param x1 The initial x coordinate of the cone.
	/// @param y1 The initial y coordinate of the cone.
	/// @param z1 The initial z coordinate of the cone.
	/// @param x2 The opposite x coordinate of the cone.
	/// @param y2 The opposite y coordinate of the cone. 
	/// @param z2 The opposite z coordinate of the cone.
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @param closed Sets whether to close (true) the bottom of the cone or not (false).
	/// @param steps How many steps are used to make the cone "round" (typically 24)
	/// @returns 
	
	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;
	
	if (__steps < 3)
	{
		__steps = 3;
	}
	
	if (__steps > 128)
	{
		__steps = 128;
	}
	
	// Create sin and cos tables
	var __cc;
	var __ss;
	
	__cc[__steps] = 0;
	__ss[__steps] = 0;
	
	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}
	
	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	
	d3d_model_primitive_begin(__ind, pr_trianglestrip);
	
	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z2, 0, 0, 1, __hrepeat * __i / __steps, __vrepeat);
		d3d_model_vertex_normal_texture(__ind, __mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}
	
	d3d_model_primitive_end(__ind);
	
	if (__closed == true)
	{
		d3d_model_primitive_begin(__ind, pr_trianglefan);
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_model_vertex_normal_texture(__ind, __mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_model_primitive_end(__ind);
	}
}

function d3d_model_create()
{
	/// @description Creates a new model and returns its index.
	/// @returns {number} returns the new model
	
	var pointcols;
	var linecols;
	var tricols;
	pointcols[0] = -1;
	linecols[0] = -1;
	tricols[0] = -1;
	
	var model = [ undefined,				// point buffer
				  undefined,				// line buffer
				  undefined,				// tri list buffer
				  undefined,				// point uv buffer
				  undefined,				// line uv buffer
				  undefined,				// tri uv buffer
				  undefined,				// point vertex buffer
				  undefined,				// line vertex buffer
				  undefined,				// tri list buffer			  
				  $00010000,/*draw_get_colour(),*/		// colour used when creating
				  -1,						// last texture used for drawing
				  0,						// num vertices
				  0,						// prim kind
				  0,						// number of non-colour point vertices
				  0,						// number of non-colour line vertices
				  0,						// number of non-colour tri vertices
				  pointcols,				// offsets to point colours
				  linecols,					// offsets to line colours
				  tricols,					// offsets to tri colours
				  
				  0, 0, 0, 0, 0, 0, 0, 0, 0,	// vertex 1
				  0, 0, 0, 0, 0, 0, 0, 0, 0,	// vertex 2
				  
				];
				  
	return model;
	
	

}

function d3d_model_cylinder()
{
	/// @description Adds a cylinder shape to the model.
	/// @param ind The model index to add the cylinder to.
	/// @param x1 The initial x coordinate of the cylinder.
	/// @param y1 The initial y coordinate of the cylinder.
	/// @param z1 The initial z coordinate of the cylinder.
	/// @param x2 The opposite x coordinate of the cylinder.
	/// @param y2 The opposite y coordinate of the cylinder. 
	/// @param z2 The opposite z coordinate of the cylinder.
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @param closed Sets whether to close (true) the bottom and top of the cylinder or not (false).
	/// @param steps How many steps are used to make the cylinder "round" (typically 24)
	/// @returns 
	
	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;
	
	if (__steps < 3)
	{
		__steps = 3;
	}
	
	if (__steps > 128)
	{
		__steps = 128;
	}
	
	// Create sin and cos tables
	var __cc;
	var __ss;
	
	__cc[__steps] = 0;
	__ss[__steps] = 0;
	
	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}
	
	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	
	if (__closed == true)
	{
		d3d_model_primitive_begin(__ind, pr_trianglefan);
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z2, 0, 0, 1, 0, __vrepeat);
		for(__i = 0; __i <= __steps; __i++)
		{
			d3d_model_vertex_normal_texture(__ind, __mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z2, 0, 0, 1, 0, __vrepeat);		
		}
		d3d_model_primitive_end(__ind);
	}
	
	d3d_model_primitive_begin(__ind, pr_trianglestrip);
	
	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_model_vertex_normal_texture(__ind, __mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z2, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, __vrepeat);
		d3d_model_vertex_normal_texture(__ind, __mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}
	
	d3d_model_primitive_end(__ind);
	
	if (__closed == true)
	{
		d3d_model_primitive_begin(__ind, pr_trianglefan);
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_model_vertex_normal_texture(__ind, __mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_model_primitive_end(__ind);
	}
}

function d3d_model_destroy()
{
	/// @description Destroys the model with the given index, freeing its memory.
	/// @param ind The index of the model to be destroyed.
	/// @returns 
	
	d3d_model_clear(argument0);
}

function d3d_model_draw()
{
	/// @description Draws the model at position (x, y, z).
	/// @param ind The index of the model to be drawn.
	/// @param x The x position to draw the model. 
	/// @param y The y position to draw the model.
	/// @param z The z position to draw the model.
	/// @param texid The texture to use for drawing the model (use -1 to use no texture).
	/// @returns
	
	var m = argument0;
	
	var tex = argument4;
	var vertsize = 36;
	var vertuvoffset = 28;
	if (tex!=-1 && tex != m[e__YYM.Texture])
	{	
	
		var texuvs = texture_get_uvs(tex);
		var uspan = texuvs[2] - texuvs[0];
		var vspan = texuvs[3] - texuvs[1];
		var ubase  = texuvs[0];
		var vbase  = texuvs[1];
	
		
		// Copy and scale\bias the unmolested UV coords to our buffers
		var __i;
		
		if ((m[e__YYM.PointB] != undefined) && (m[e__YYM.PointUVB] != undefined))
		{
			var numverts = buffer_tell(m[e__YYM.PointUVB]) / 8;
					
			buffer_seek(m[e__YYM.PointUVB], buffer_seek_start, 0);
			var __uvpos = vertuvoffset;
			var __src = m[e__YYM.PointUVB];
			var __dest = m[e__YYM.PointB];
			for(__i = 0; __i < numverts; __i++)
			{
				var __u = buffer_read(__src, buffer_f32);
				var __v = buffer_read(__src, buffer_f32);
				
				__u = (__u * uspan) + ubase;
				__v = (__v * vspan) + vbase;
							
				buffer_poke(__dest, __uvpos, buffer_f32, __u);
				buffer_poke(__dest, __uvpos + 4, buffer_f32, __v);
				
				__uvpos += vertsize;
			}
		}
		
		if ((m[e__YYM.LineB] != undefined) && (m[e__YYM.LineUVB] != undefined))
		{
			var numverts = buffer_tell(m[e__YYM.LineUVB]) / 8;
					
			buffer_seek(m[e__YYM.LineUVB], buffer_seek_start, 0);
			var __uvpos = vertuvoffset;
			var __src = m[e__YYM.LineUVB];
			var __dest = m[e__YYM.LineB];
			for(__i = 0; __i < numverts; __i++)
			{
				var __u = buffer_read(__src, buffer_f32);
				var __v = buffer_read(__src, buffer_f32);
				
				__u = (__u * uspan) + ubase;
				__v = (__v * vspan) + vbase;
							
				buffer_poke(__dest, __uvpos, buffer_f32, __u);
				buffer_poke(__dest, __uvpos + 4, buffer_f32, __v);
				
				__uvpos += vertsize;
			}
		}
		
		if ((m[e__YYM.TriB] != undefined) && (m[e__YYM.TriUVB] != undefined))
		{
			var numverts = buffer_tell(m[e__YYM.TriUVB]) / 8;
					
			buffer_seek(m[e__YYM.TriUVB], buffer_seek_start, 0);
			var __uvpos = vertuvoffset;
			var __src = m[e__YYM.TriUVB];
			var __dest =m[e__YYM.TriB];
			for(__i = 0; __i < numverts; __i++)
			{
				var __u = buffer_read(__src, buffer_f32);
				var __v = buffer_read(__src, buffer_f32);
				
				__u = (__u * uspan) + ubase;
				__v = (__v * vspan) + vbase;
							
				buffer_poke(__dest, __uvpos, buffer_f32, __u);
				buffer_poke(__dest, __uvpos + 4, buffer_f32, __v);
				
				__uvpos += vertsize;
			}
		}
		
		
		m[@e__YYM.Texture] = tex;
	
		// remove the current Vertex Buffers if present
		if (m[e__YYM.PointVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.PointVB]);
			m[@e__YYM.PointVB] = undefined;
		} // end if
	
		if (m[e__YYM.LineVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.LineVB]);
			m[@e__YYM.LineVB] = undefined;
		} // end if
		
		if (m[e__YYM.TriVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.TriVB]);
			m[@e__YYM.TriVB] = undefined;
		} // end if
	}
	
	
	var currColour = draw_get_colour() | ((draw_get_alpha()*255.0) << 24);
	// if colour is different from the previous cached entry then rebuild the model
	if ((currColour != m[e__YYM.Colour]) && ((m[e__YYM.NumPointCols] > 0) || (m[e__YYM.NumLineCols] > 0) || (m[e__YYM.NumTriCols] > 0))) {
	
		var __numPointCols = m[e__YYM.NumPointCols];
		var __numLineCols = m[e__YYM.NumLineCols];
		var __numTriCols = m[e__YYM.NumTriCols];
	
		// go through and change all the entries with no colour in them to be the same as the draw colour
		var __i;
		
		if (m[e__YYM.PointB] != undefined)
		{
			var __offsets = m[e__YYM.PointCols];
			var __dest = m[e__YYM.PointB];
			for(__i = 0; __i < __numPointCols; __i++)
			{
				buffer_poke(__dest, __offsets[__i], buffer_u32, currColour);
			}
		}
		
		if (m[e__YYM.LineB] != undefined)
		{
			var __offsets = m[e__YYM.LineCols];
			var __dest = m[e__YYM.LineB];
			for(__i = 0; __i < __numLineCols; __i++)
			{
				buffer_poke(__dest, __offsets[__i], buffer_u32, currColour);
			}
		}
		
		if (m[e__YYM.TriB] != undefined)
		{
			var __offsets = m[e__YYM.TriCols];
			var __dest = m[e__YYM.TriB];
			for(__i = 0; __i < __numTriCols; __i++)
			{
				buffer_poke(__dest, __offsets[__i], buffer_u32, currColour);
			}
		}
	
		// remove the current Vertex Buffers if present
		if (m[e__YYM.PointVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.PointVB]);
			m[@e__YYM.PointVB] = undefined;
		} // end if
	
		if (m[e__YYM.LineVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.LineVB]);
			m[@e__YYM.LineVB] = undefined;
		} // end if
		
		if (m[e__YYM.TriVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.TriVB]);
			m[@e__YYM.TriVB] = undefined;
		} // end if
		
		m[@e__YYM.Colour] = currColour;
	} // end if
	
	// set the translation to this (argument1, argument2, argument3)
	var mW = matrix_get( matrix_world );
	var mT = matrix_build( argument1, argument2, argument3, 0, 0, 0, 1, 1, 1 );
	var mNew = matrix_multiply( mT, mW );
	matrix_set( matrix_world, mNew );
	
	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	
	
	// draw the tri list buffer
	if (m[e__YYM.TriB] != undefined) {
	
		// convert to a vertex buffer if need be
		if (m[e__YYM.TriVB] == undefined) {
			m[@e__YYM.TriVB] = vertex_create_buffer_from_buffer( m[e__YYM.TriB], global.__d3dPrimVF );
			vertex_freeze(m[e__YYM.TriVB]);		
		} // end if
		
		vertex_submit( m[e__YYM.TriVB], pr_trianglelist, argument4 );
	} // end if
	
	// draw the line buffer
	if (m[e__YYM.LineB] != undefined) {
	
		// convert to a vertex buffer if need be
		if (m[e__YYM.LineVB] == undefined) {
			m[@e__YYM.LineVB] = vertex_create_buffer_from_buffer( m[e__YYM.LineB], global.__d3dPrimVF );
			vertex_freeze(m[e__YYM.LineVB]);
		} // end if
		
		vertex_submit( m[e__YYM.LineVB], pr_linelist, argument4 );
	} // end if
	
	// draw the point buffer
	if (m[e__YYM.PointB] != undefined) {
	
		// convert to a vertex buffer if need be
		if (m[e__YYM.PointVB] == undefined) {
			m[@e__YYM.PointVB] = vertex_create_buffer_from_buffer( m[e__YYM.PointB], global.__d3dPrimVF );
			vertex_freeze(m[e__YYM.PointVB]);
		} // end if
		
		vertex_submit( m[e__YYM.PointVB], pr_pointlist,  argument4 );
	} // end if
	
	// Restore the matrix
	matrix_set( matrix_world, mW );
	
	gpu_set_texrepeat(__oldrep);

}

function d3d_model_ellipsoid()
{
	/// @description Adds an ellipsoid shape to the model.
	/// @param ind The model index to add the ellipsoid to.
	/// @param x1 The initial x coordinate of the ellipsoid.
	/// @param y1 The initial y coordinate of the ellipsoid.
	/// @param z1 The initial z coordinate of the ellipsoid.
	/// @param x2 The opposite x coordinate of the ellipsoid.
	/// @param y2 The opposite y coordinate of the ellipsoid. 
	/// @param z2 The opposite z coordinate of the ellipsoid.
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @param steps How many steps are used to make the ellipsoid "round" (typically 24)
	/// @returns 
	
	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __steps = argument9;
	
	if (__steps < 3)
	{
		__steps = 3;
	}
	
	if (__steps > 128)
	{
		__steps = 128;
	}
	
	// Create sin and cos tables
	var __cc;
	var __ss;
	
	__cc[__steps] = 0;
	__ss[__steps] = 0;
	
	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}
	
	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __mz = (__z2 + __z1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	var __rz = (__z2 - __z1) / 2;
	
	var __rows = (__steps + 1) / 2;
	var __j;
	
	for(__j = 0; __j <= (__rows - 1); __j++)
	{
		var __row1rad = (__j*pi)/__rows;
		var __row2rad = ((__j+1)*pi)/__rows;
		var __rh1 = cos(__row1rad);
		var __rd1 = sin(__row1rad);
		var __rh2 = cos(__row2rad);
		var __rd2 = sin(__row2rad);
		
		d3d_model_primitive_begin(__ind, pr_trianglestrip);
		
		for(__i = 0; __i <= __steps; __i++)
		{
			// Some common subexpressions here that could be eliminated
			d3d_model_vertex_normal_texture(__ind, __mx+__rx*__rd1*__cc[__i], __my+__ry*__rd1*__ss[__i], __mz+__rz*__rh1,__rd1*__cc[__i], __rd1*__ss[__i], __rh1, __hrepeat*__i/__steps, __j*__vrepeat/__rows);
			d3d_model_vertex_normal_texture(__ind, __mx+__rx*__rd2*__cc[__i], __my+__ry*__rd2*__ss[__i], __mz+__rz*__rh2,__rd2*__cc[__i], __rd2*__ss[__i], __rh2, __hrepeat*__i/__steps, (__j+1)*__vrepeat/__rows);
		}
		
		d3d_model_primitive_end(__ind);
	}

}

function d3d_model_floor()
{
	/// @description Adds a floor shape to the model.
	/// @param ind The model index to add the floor to.
	/// @param x1 The initial x coordinate of the floor.
	/// @param y1 The initial y coordinate of the floor.
	/// @param z1 The initial z coordinate of the floor.
	/// @param x2 The opposite x coordinate of the floor.
	/// @param y2 The opposite y coordinate of the floor. 
	/// @param z2 The opposite z coordinate of the floor.
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @returns 
	
	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	
	var __xdiff = __x2 - __x1;
	var __zdiff = __z2 - __z1;
	
	var __lsquared = (__xdiff * __xdiff) + (__zdiff * __zdiff);
	if (__lsquared == 0)
		return 0;
		
	var __l = sqrt(__lsquared);
	
	var __nx = -__zdiff / __l;
	var __nz = __xdiff / __l;
	
	d3d_model_primitive_begin(__ind, pr_trianglefan);
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, __nx, 0, __nz, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, __nx, 0, __nz, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, __nx, 0, __nz, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, __nx, 0, __nz, __hrepeat, 0);
	
	d3d_model_primitive_end(__ind);
}

function d3d_model_load()
{
	/// @description  Loads the model from the indicated file name.
	/// @param ind The index of the model to be loaded.
	/// @param fname The name of the file to load the model from.
	
	var __ind = argument0;
	var __fname = argument1;
	
	var __file = file_text_open_read(__fname);
	if (__file == -1)
		return -1;
		
	// Get version number
	var __version = file_text_read_real(__file);
	if (__version != 100)
	{
		file_text_close(__file);
		return - 1; // wrong version
	}
	file_text_readln(__file);
	
	// Get number of entries
	var __numthings = file_text_read_real(__file);
	file_text_readln(__file);
	
	// At this point, scrub the contents of the passed-in model
	d3d_model_clear(__ind);
	
	// Now parse the contents of the file
	var __currthing = 0;
	var __i;
	while(__currthing < __numthings)
	{
		// Every entry is 11 values - 1 'command' and 10 parameters
		var __kind = round(file_text_read_real(__file));
		var __args;
		for(__i = 0; __i < 10; __i++)
		{
			__args[__i] = file_text_read_real(__file);
		}
		file_text_readln(__file);
		
		switch(__kind)
		{
			case e__YYMKIND.PRIMITIVE_BEGIN:	d3d_model_primitive_begin(__ind, round(__args[0])); break;
			case e__YYMKIND.PRIMITIVE_END:		d3d_model_primitive_end(__ind); break;
			case e__YYMKIND.VERTEX:				d3d_model_vertex(__ind, __args[0], __args[1], __args[2]); break;
			case e__YYMKIND.VERTEX_COLOR:		d3d_model_vertex_color(__ind, __args[0], __args[1], __args[2], round(__args[3]), __args[4]); break;
			case e__YYMKIND.VERTEX_TEX:			d3d_model_vertex_texture(__ind, __args[0], __args[1], __args[2], __args[3], __args[4]); break;
			case e__YYMKIND.VERTEX_TEX_COLOR:	d3d_model_vertex_texture_color(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], round(__args[5]), __args[6]); break;
			case e__YYMKIND.VERTEX_N:			d3d_model_vertex_normal(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5]); break;
			case e__YYMKIND.VERTEX_N_COLOR:		d3d_model_vertex_normal_color(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], round(__args[6]), __args[7]); break;
			case e__YYMKIND.VERTEX_N_TEX:		d3d_model_vertex_normal_texture(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;
			case e__YYMKIND.VERTEX_N_TEX_COLOR: d3d_model_vertex_normal_texture_color(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8]), __args[9]); break;
			case e__YYMKIND.SHAPE_BLOCK:		d3d_model_block(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;
			case e__YYMKIND.SHAPE_CYLINDER:		d3d_model_cylinder(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8]), round(__args[9])); break;
			case e__YYMKIND.SHAPE_CONE:			d3d_model_cone(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8]), round(__args[9])); break;
			case e__YYMKIND.SHAPE_ELLIPSOID:	d3d_model_ellipsoid(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8])); break;
			case e__YYMKIND.SHAPE_WALL:			d3d_model_wall(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;
			case e__YYMKIND.SHAPE_FLOOR:		d3d_model_floor(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;		
		};
		
		__currthing++;
	}
	
		
	file_text_close(__file);
}

function d3d_model_primitive_begin()
{
	/// @description  Begins the process of defining a primitive that is to be added to a model in 3D.
	/// @param ind The index of the model to add the primitive to.
	/// @param kind The kind of primitive you are going to draw.
	
	var m = argument0;
	m[@ e__YYM.PrimKind] = argument1;
	

}

function d3d_model_primitive_end()
{
	/// @description  Ends the process of adding primitives to a model in 3D.
	/// @param ind The index of the model to end the addition of primitives to.
	
	var m = argument0;
	m[@ e__YYM.PrimKind] = 0;
	m[@ e__YYM.NumVerts] = 0;
	

}

function d3d_model_save()
{
	/// @description  Saves the model to the indicated file name.
	/// @param ind The index of the model to be saved.
	/// @param fname The name of the file to save the model to.
	
	var __ind = argument0;
	var __fname = argument1;
	
	var __file = file_text_open_write(__fname);
	if (__file == -1)
		return -1;
		
	var __vertexsize = 36;		// combined size of position, normal, colour and uv
		
	// Count up the number of 'things' we have in the model
	var __numthings = 0;
	var __numpointverts = 0;
	var __numlineverts = 0;
	var __numtriverts = 0;
	
	if (__ind[e__YYM.PointB] != undefined)
	{
		var __buffpos = buffer_tell(__ind[e__YYM.PointB]);
		if (__buffpos > 0)
		{
			__numthings += 2;		// include primitive begin\end
		}
		
		// Now add the number of vertices
		__numpointverts = __buffpos / __vertexsize;
		__numthings += __numpointverts;
	}
	
	if (__ind[e__YYM.LineB] != undefined)
	{
		var __buffpos = buffer_tell(__ind[e__YYM.LineB]);
		if (__buffpos > 0)
		{
			__numthings += 2;		// include primitive begin\end
		}
		
		// Now add the number of vertices
		__numlineverts = __buffpos / __vertexsize;
		__numthings += __numlineverts;
	}
	
	if (__ind[e__YYM.TriB] != undefined)
	{
		var __buffpos = buffer_tell(__ind[e__YYM.TriB]);
		if (__buffpos > 0)
		{
			__numthings += 2;		// include primitive begin\end
		}
		
		// Now add the number of vertices
		__numtriverts = __buffpos / __vertexsize;
		__numthings += __numtriverts;
	}
	
	file_text_write_string(__file, "100");
	file_text_writeln(__file);
	file_text_write_string(__file, string_format(__numthings, 0, 0));
	file_text_writeln(__file);
	
	if (__ind[e__YYM.PointB] != undefined)
	{	
		var __buf = __ind[e__YYM.PointB];
		if (__numpointverts > 0)
		{
			// Primitive begin (pointlist)
			file_text_write_string(__file, "0 " + string_format(pr_pointlist, 10, 4) + " 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
			
			// Vertices		
			buffer_seek(__buf, buffer_seek_start, 0);		// after reading through the whole buffer we should end up back at the end
			var __i;
			for(__i = 0; __i < __numpointverts; __i++)
			{			
				var __x = buffer_read(__buf, buffer_f32);
				var __y = buffer_read(__buf, buffer_f32);
				var __z = buffer_read(__buf, buffer_f32);
				var __nx = buffer_read(__buf, buffer_f32);
				var __ny = buffer_read(__buf, buffer_f32);
				var __nz = buffer_read(__buf, buffer_f32);
				var __colalpha = buffer_read(__buf, buffer_u32);
				var __u = buffer_read(__buf, buffer_f32);
				var __v = buffer_read(__buf, buffer_f32);
				
				// Need to separate colour and alpha
				var __col = __colalpha & $00ffffff;
				var __alpha = ((__colalpha >> 24) & $ff) / 255.0;
				
				file_text_write_string(__file, "9"
										+ " " + string_format(__x, 10, 4)
										+ " " + string_format(__y, 10, 4)
										+ " " + string_format(__z, 10, 4)
										+ " " + string_format(__nx, 10, 4)
										+ " " + string_format(__ny, 10, 4)
										+ " " + string_format(__nz, 10, 4)
										+ " " + string_format(__u, 10, 4)
										+ " " + string_format(__v, 10, 4)
										+ " " + string_format(__col, 10, 4)
										+ " " + string_format(__alpha, 10, 4)
										);
				file_text_writeln(__file);
			}
			
			// Primitive end
			file_text_write_string(__file, "1 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		}
	}
	
	if (__ind[e__YYM.LineB] != undefined)
	{	
		var __buf = __ind[e__YYM.LineB];
		if (__numlineverts > 0)
		{
			// Primitive begin (pointlist)
			file_text_write_string(__file, "0 " + string_format(pr_linelist, 10, 4) + " 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
			
			// Vertices		
			buffer_seek(__buf, buffer_seek_start, 0);		// after reading through the whole buffer we should end up back at the end
			var __i;
			for(__i = 0; __i < __numlineverts; __i++)
			{			
				var __x = buffer_read(__buf, buffer_f32);
				var __y = buffer_read(__buf, buffer_f32);
				var __z = buffer_read(__buf, buffer_f32);
				var __nx = buffer_read(__buf, buffer_f32);
				var __ny = buffer_read(__buf, buffer_f32);
				var __nz = buffer_read(__buf, buffer_f32);
				var __colalpha = buffer_read(__buf, buffer_u32);
				var __u = buffer_read(__buf, buffer_f32);
				var __v = buffer_read(__buf, buffer_f32);
				
				// Need to separate colour and alpha
				var __col = __colalpha & $00ffffff;
				var __alpha = ((__colalpha >> 24) & $ff) / 255.0;
				
				file_text_write_string(__file, "9"
										+ " " + string_format(__x, 10, 4)
										+ " " + string_format(__y, 10, 4)
										+ " " + string_format(__z, 10, 4)
										+ " " + string_format(__nx, 10, 4)
										+ " " + string_format(__ny, 10, 4)
										+ " " + string_format(__nz, 10, 4)
										+ " " + string_format(__u, 10, 4)
										+ " " + string_format(__v, 10, 4)
										+ " " + string_format(__col, 10, 4)
										+ " " + string_format(__alpha, 10, 4)
										);
				file_text_writeln(__file);
			}
			
			// Primitive end
			file_text_write_string(__file, "1 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		}
	}
	
	if (__ind[e__YYM.TriB] != undefined)
	{	
		var __buf = __ind[e__YYM.TriB];
		if (__numtriverts > 0)
		{
			// Primitive begin (pointlist)
			file_text_write_string(__file, "0 " + string_format(pr_trianglelist, 10, 4) + " 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
			
			// Vertices		
			buffer_seek(__buf, buffer_seek_start, 0);		// after reading through the whole buffer we should end up back at the end
			var __i;
			for(__i = 0; __i < __numtriverts; __i++)
			{			
				var __x = buffer_read(__buf, buffer_f32);
				var __y = buffer_read(__buf, buffer_f32);
				var __z = buffer_read(__buf, buffer_f32);
				var __nx = buffer_read(__buf, buffer_f32);
				var __ny = buffer_read(__buf, buffer_f32);
				var __nz = buffer_read(__buf, buffer_f32);
				var __colalpha = buffer_read(__buf, buffer_u32);
				var __u = buffer_read(__buf, buffer_f32);
				var __v = buffer_read(__buf, buffer_f32);
				
				// Need to separate colour and alpha
				var __col = __colalpha & $00ffffff;
				var __alpha = ((__colalpha >> 24) & $ff) / 255.0;
				
				file_text_write_string(__file, "9"
										+ " " + string_format(__x, 10, 4)
										+ " " + string_format(__y, 10, 4)
										+ " " + string_format(__z, 10, 4)
										+ " " + string_format(__nx, 10, 4)
										+ " " + string_format(__ny, 10, 4)
										+ " " + string_format(__nz, 10, 4)
										+ " " + string_format(__u, 10, 4)
										+ " " + string_format(__v, 10, 4)
										+ " " + string_format(__col, 10, 4)
										+ " " + string_format(__alpha, 10, 4)
										);
				file_text_writeln(__file);
			}
			
			// Primitive end
			file_text_write_string(__file, "1 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		}
	}
		
	file_text_close(__file);
}

function d3d_model_vertex()
{
	/// @description  Add vertex (x,y,z) to the model.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, $00010000, 0, 0 );
}

function d3d_model_vertex_color()
{
	/// @description  Add vertex (x,y,z) to the model with colour values.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param col The color to blend with vertex.
	/// @param alpha The alpha value of the vertex.
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument4 + ((argument5*255)<<24), 0, 0 );

}

function d3d_model_vertex_colour()
{
	/// @description  Add vertex (x,y,z) to the model with colour values.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param col The colour to blend with vertex.
	/// @param alpha The alpha value of the vertex.
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument4 + ((argument5*255)<<24), 0, 0 );
}

function d3d_model_vertex_normal()
{
	/// @description  Defines a vertex for a primitive in 3D along with its corresponding normal.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xn The x component of the normal vector.
	/// @param yn The y component of the normal vector.
	/// @param zn The z component of the normal vector.
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, $00010000, 0, 0 );

}

function d3d_model_vertex_normal_color()
{
	/// @description  Defines a primitive vertex for a model in 3D along with its corresponding normal, colour blending and alpha.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xn The x component of the normal vector.
	/// @param yn The y component of the normal vector.
	/// @param zn The z component of the normal vector.
	/// @param col The color to blend with the vertex (c_white or -1 is no blend).
	/// @param alpha The alpha of the vertex (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7 + ((argument8*255)<<24), 0, 0 );
	

}

function d3d_model_vertex_normal_colour()
{
	/// @description  Defines a primitive vertex for a model in 3D along with its corresponding normal, colour blending and alpha.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xn The x component of the normal vector.
	/// @param yn The y component of the normal vector.
	/// @param zn The z component of the normal vector.
	/// @param col The colour to blend with the vertex (c_white or -1 is no blend).
	/// @param alpha The alpha of the vertex (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7 + ((argument8*255)<<24), 0, 0 );
}

function d3d_model_vertex_normal_texture()
{
	/// @description  Defines a primitive vertex for a textured model in 3D along with its corresponding normal.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xn The x component of the normal vector.
	/// @param yn The y component of the normal vector.
	/// @param zn The z component of the normal vector.
	/// @param xtex Starting x coordinate within the texture (0 - 1). 
	/// @param ytex Starting y coordinate within the texture (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, $00010000, argument7, argument8 );

}

function d3d_model_vertex_normal_texture_color()
{
	/// @description  Defines a primitive vertex for a textured model in 3D along with its corresponding normal, color blending and alpha.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xn The x component of the normal vector.
	/// @param yn The y component of the normal vector.
	/// @param zn The z component of the normal vector.
	/// @param xtex Starting x coordinate within the texture (0 - 1). 
	/// @param ytex Starting y coordinate within the texture (0 - 1).
	/// @param col The color to blend with the vertex (c_white or -1 is no blend).
	/// @param alpha The alpha of the vertex (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument9 + ((argument10*255)<<24), argument7, argument8  );

}

function d3d_model_vertex_normal_texture_colour()
{
	/// @description  Defines a primitive vertex for a textured model in 3D along with its corresponding normal, colour blending and alpha.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xn The x component of the normal vector.
	/// @param yn The y component of the normal vector.
	/// @param zn The z component of the normal vector.
	/// @param xtex Starting x coordinate within the texture (0 - 1). 
	/// @param ytex Starting y coordinate within the texture (0 - 1).
	/// @param col The colour to blend with the vertex (c_white or -1 is no blend).
	/// @param alpha The alpha of the vertex (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument9 + ((argument10*255)<<24), argument7, argument8  );
}

function d3d_model_vertex_texture()
{
	/// @description  Add vertex (x,y,z) to the model with texture values.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xtex Starting x coordinate within the texture (0 - 1). 
	/// @param ytex Starting y coordinate within the texture (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, $00010000, argument4, argument5 );

}

function d3d_model_vertex_texture_color()
{
	/// @description  Add vertex (x,y,z) to the model with texture and color values.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xtex Starting x coordinate within the texture (0 - 1). 
	/// @param ytex Starting y coordinate within the texture (0 - 1).
	/// @param col The color to blend with the vertex (c_white or -1 is no blend).
	/// @param alpha The alpha of the vertex (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument6 + ((argument7*255)<<24), argument4, argument5 );

}

function d3d_model_vertex_texture_colour()
{
	/// @description  Add vertex (x,y,z) to the model with texture and colour values.
	/// @param ind The index of the model to add the primitive to.
	/// @param x The x coordinate of the vertex.
	/// @param y The y coordinate of the vertex. 
	/// @param z The z coordinate of the vertex.
	/// @param xtex Starting x coordinate within the texture (0 - 1). 
	/// @param ytex Starting y coordinate within the texture (0 - 1).
	/// @param col The colour to blend with the vertex (c_white or -1 is no blend).
	/// @param alpha The alpha of the vertex (0 - 1).
	
	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument6 + ((argument7*255)<<24), argument4, argument5 );
}

function d3d_model_wall()
{
	/// @description Adds a wall shape to the model.
	/// @param ind The model index to add the wall to.
	/// @param x1 The initial x coordinate of the wall.
	/// @param y1 The initial y coordinate of the wall.
	/// @param z1 The initial z coordinate of the wall.
	/// @param x2 The opposite x coordinate of the wall.
	/// @param y2 The opposite y coordinate of the wall. 
	/// @param z2 The opposite z coordinate of the wall.
	/// @param hrepeat Amount of horizontal repetitions for the texture.
	/// @param vrepeat Amount of vertical repetitions for the texture.
	/// @returns 
	
	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	
	var __xdiff = __x2 - __x1;
	var __ydiff = __y2 - __y1;
	
	var __lsquared = (__xdiff * __xdiff) + (__ydiff * __ydiff);
	if (__lsquared == 0)
		return 0;
		
	var __l = sqrt(__lsquared);
	
	var __nx = __ydiff / __l;
	var __ny = -__xdiff / __l;
	
	d3d_model_primitive_begin(__ind, pr_trianglefan);
	
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, __nx, __ny, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, __nx, __ny, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, __nx, __ny, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, __nx, __ny, 0, 0, __vrepeat);
	
	d3d_model_primitive_end(__ind);

}

function d3d_primitive_begin()
{
	/// @description  d3d - begin making a primitive stream
	/// @param kind Primitive kind
	
	if (global.__d3dPrimKind != -1) {
		show_debug_message( "ERROR : cannot begin a primitive before end called on previous")
	}
	
	global.__d3dPrimKind = argument0;
	global.__d3dPrimTex = -1;
	vertex_begin(global.__d3dPrimBuffer, global.__d3dPrimVF);

}

function d3d_primitive_begin_texture()
{
	/// @description  d3d - begin making a primitive stream
	/// @param kind Primitive kind
	/// @param tex Texture Index
	
	if (global.__d3dPrimKind != -1) {
		show_debug_message( "ERROR : cannot begin a primitive before end called on previous")
	}
	
	global.__d3dPrimKind = argument0;
	global.__d3dPrimTex = argument1;
	var __uvs = texture_get_uvs(global.__d3dPrimTex);
	global.__d3dPrimTexX = __uvs[0];
	global.__d3dPrimTexY = __uvs[1];
	global.__d3dPrimTexW = __uvs[2] - __uvs[0];
	global.__d3dPrimTexH = __uvs[3] - __uvs[1];
	vertex_begin( global.__d3dPrimBuffer, global.__d3dPrimVF );
}

function d3d_primitive_end()
{
	/// @description d3d - end the primitive stream
	
	if (global.__d3dPrimKind != -1) {
	
		vertex_end( global.__d3dPrimBuffer );
		vertex_submit( global.__d3dPrimBuffer, global.__d3dPrimKind, global.__d3dPrimTex );
	
		// mark this as finished
		global.__d3dPrimKind = -1;
	} else {
		show_debug_message( "d3d_primitive_end :: with no d3d_primitive_begin ");
	}

}

function d3d_set_culling()
{
	/// @description  d3d - backface culling on or off
	/// @param enable true if enabled, false if disabled
	
	//gpu_set_cullmode( argument0 ? cull_clockwise : cull_noculling );
	gpu_set_cullmode( argument0 ? cull_counterclockwise : cull_noculling );
}

function d3d_set_depth()
{
	/// @description d3d - set depth
	/// @param val value of depth
	global.__d3dDepth=argument0;
}

function d3d_set_fog()
{
	/// @description  d3d - set fog enable/disable and colour
	/// @param enable true if enabled, false if disabled
	/// @param colour	colour of the fog
	/// @param near	distance to when fog starts
	/// @param far	distance to when fog becomes absolute
	
	gpu_set_fog(argument0, argument1, argument2, argument3 );
}

function d3d_set_hidden()
{
	/// @description d3d - set depth testing
	/// @param enable true if enabled, false if disabled
	
	gpu_set_ztestenable( argument0 );
}

function d3d_set_lighting()
{
	/// @description  d3d - set lighting
	/// @param enable true if enabled, false if disabled
	
	draw_set_lighting( argument0 );
}

function d3d_set_perspective()
{
	/// @description d3d - set perspective
	/// @param enable true if enabled, false if disabled
	
	//camera_apply(global.__d3dCamera);
	
	var __persp = argument0;
	if (global.__d3d == false)
		__persp = false;
		
	// Now find all cameras everywhere - the default camera, all the views in the current room and all the cameras in every other room
	// NOTE: this currently won't handle rooms that are created in code (using room_add())
	
	// The default camera is automatically updated by the runner so we just need to give it a hint of whether it is ortho or perspective
	var __mat = camera_get_proj_mat(camera_get_default());
	
	if (__persp)
	{
		__mat[11] = 1.0;
	}
	else
	{
		__mat[11] = 0.0;
	}
	
	camera_set_proj_mat(camera_get_default(), __mat);
	
	
	// Now loop through all the others
	var __numcams = 0;
	var __cams = [];
	var __i;
	for(__i = 0; __i < 8; __i++)
	{
		if (view_camera[__i] != -1)
		{
			__cams[__numcams*3] = view_camera[__i];
			__cams[__numcams*3+1] = view_camera[__i];
			__cams[__numcams*3+2] = view_camera[__i];
			__numcams++;
		}
	}
	
	var __currroom = room_first;
	while(__currroom != -1)
	{
		for(__i = 0; __i < 8; __i++)
		{
			var __cam = room_get_camera(__currroom, __i);
			if (__cam != -1)
			{
				__cams[__numcams] = __cam;
				__numcams++;
			}
		}
		
		__currroom = room_next(__currroom);
	}
	
	// Now loop through all the cameras
	for(__i = 0; __i < __numcams; __i++)
	{
		var __cam = __cams[__i];
		var __mat = camera_get_proj_mat(__cam);
		var __ispersp = (__mat[11] != 0.0) ? true : false;
		
		if (__ispersp != __persp)
		{
			// Okay, I'm going to assume that, if this is an imported project, all the cameras that have been set up are view-based
			// This means that they should have valid view parameters
			if (camera_get_view_width(__cam) > 0.0)
			{
				// okay, we'll assume this is a camera that has been previously set up with a view
				var __width = camera_get_view_width(__cam);
				var __height = camera_get_view_height(__cam);			
				
				if (__persp)
				{
					var __projmat = matrix_build_projection_perspective(1.0, -(__height/__width), 1.0, 32000.0);
					camera_set_proj_mat(__cam, __projmat);
				}
				else
				{
					var __projmat = matrix_build_projection_ortho(__width, __height, -16000.0, 16000.0);
					camera_set_proj_mat(__cam, __projmat);
				}
			}
		}
	}
	
	//camera_apply(camera_get_active());
	

}

function d3d_set_projection()
{
	/// @description  @description d3d - set projection 
	/// @param xFrom	x of from position
	/// @param yFrom	y of from position
	/// @param zFrom	z of from position
	/// @param xTo		x of to position
	/// @param yTo		y of to position
	/// @param zTo		z of to position
	/// @param xUp		x of up vector
	/// @param yUp		y of up vector
	/// @param zUp		z of up vector
	
	var m = matrix_build_lookat( argument0, argument1, argument2, 
								 argument3, argument4, argument5,
								 argument6, argument7, argument8 );
	
	var cam = camera_get_active();
	camera_set_view_mat( cam, m );
	if( !global.__d3d ) {
		//apply default ortho projection
		var mproj = matrix_build_projection_ortho(camera_get_view_width(cam),camera_get_view_height(cam),1,32000);
		camera_set_proj_mat( cam, mproj);
	}
	camera_apply(cam);
}

function d3d_set_projection_ext()
{
	/// @description d3d - set projection 
	/// @param xFrom	x of from position
	/// @param yFrom	y of from position
	/// @param zFrom	z of from position
	/// @param xTo		x of to position
	/// @param yTo		y of to position
	/// @param zTo		z of to position
	/// @param xUp		x of up vector
	/// @param yUp		y of up vector
	/// @param zUp		z of up vector
	/// @param fov		field of view angle
	/// @param aspect	aspect ration
	/// @param zmin		z buffer min
	/// @param zmax		z buffer max
	
	var mV = matrix_build_lookat( argument0, argument1, argument2, 
								 argument3, argument4, argument5,
								 argument6, argument7, argument8 );
	var mP = matrix_build_projection_perspective_fov( -argument9, -argument10, argument11, argument12 );
	
	camera_set_view_mat( camera_get_active(), mV );
	camera_set_proj_mat( camera_get_active(), mP );
	camera_apply( camera_get_active() );

}

function d3d_set_projection_ortho()
{
	/// @description d3d - set orthographic 
	/// @param x		x of tl corner
	/// @param y		y of tl corner
	/// @param w		w of view
	/// @param h		h of view
	/// @param angle	rotation angle of the projection
	
	var xx = argument0;
	var yy = argument1;
	var ww = argument2;
	var hh = argument3;
	var angle = argument4;
	
	var mV = matrix_build_lookat( xx+ww/2, yy+hh/2, -16000, 
								  xx+ww/2, yy+hh/2, 0,
								 dsin(-angle), dcos(-angle), 0 );
	var mP = matrix_build_projection_ortho( ww, hh, 1, 32000 );
	
	//camera_set_view_mat( global.__d3dCamera, mV );
	//camera_set_proj_mat( global.__d3dCamera, mP );
	//camera_apply( global.__d3dCamera );
	camera_set_view_mat( camera_get_active(), mV );
	camera_set_proj_mat( camera_get_active(), mP );
	camera_apply( camera_get_active() );
}

function d3d_set_projection_perspective()
{
	/// @description d3d - set projection perspective
	/// @param x		x of tl corner
	/// @param y		y of tl corner
	/// @param w		w of view
	/// @param h		h of view
	/// @param angle	rotation angle of the projection
	var xx = argument0;
	var yy = argument1;
	var ww = argument2;
	var hh = argument3;
	var angle = argument4;
	
	var mV = matrix_build_lookat( xx+ww/2, yy+hh/2, -ww, 
								  xx+ww/2, yy+hh/2, 0,
								 dsin(-angle), dcos(-angle), 0 );
	var mP = matrix_build_projection_perspective( ww/ww, -hh/ww, 1, 32000 );
	
	camera_set_view_mat( camera_get_active(), mV );
	camera_set_proj_mat( camera_get_active(), mP );
	camera_apply( camera_get_active() );
}

function d3d_set_shading()
{
	/// @description d3d - set shading
	/// @param enable	true if enabled, false if disabled
	
	if (!global.__d3dDeprecatedMessage[0]) {
		show_debug_message( "d3d_set_shading is deprecated as it needs to be done in the shader now" );
		global.__d3dDeprecatedMessage[0] = true;
	} 

}

function d3d_set_zwriteenable()
{
	/// @description d3d - set z write enable
	/// @param enable	true if enabled, false if disabled
	
	gpu_set_zwriteenable( argument0 );

}

function d3d_start()
{
	/// @description d3d - enable 3d
	
	var ret = global.__d3d;
	global.__d3d = true;
	//camera_apply(global.__d3dCamera);
	gpu_set_ztestenable(true);
	gpu_set_zwriteenable(true);
	return ret;

}

function d3d_transform_add_rotation_axis()
{
	/// @description d3d - Sets the transformation to a rotation around the axis indicated by the vector with the indicated amount.
	/// @param xa the x component of the transform vector
	/// @param ya the y component of the transform vector
	/// @param za the z component of the transform vector
	/// @param angle the angle to rotate the transform through the vector
	
	// get the sin and cos of the angle passed in
	var c = dcos(-argument3);
	var s = dsin(-argument3);
	var omc = 1 - c;
	
	// normalise the input vector
	var xx = argument0;
	var yy = argument1;
	var zz = argument2;
	var length2 = sqr(xx) + sqr(yy) + sqr(zz);
	var length = sqrt(length2);
	xx /= length;
	yy /= length;
	zz /= length;
	
	// build the rotation matrix
	var mT;
	mT[0] = omc * xx * xx + c;
	mT[1] = omc * xx * yy + s * zz;
	mT[2] = omc * xx * zz - s * yy;
	mT[3] = 0;
	
	mT[4] = omc * xx * yy - s * zz;
	mT[5] = omc * yy * yy + c;
	mT[6] = omc * yy * zz + s * xx;
	mT[7] = 0;
	
	mT[8] = omc * xx * zz + s * yy;
	mT[9] = omc * yy * zz - s * xx;
	mT[10] = omc * zz * zz + c;
	mT[11] = 0;
	
	mT[12] = 0;
	mT[13] = 0;
	mT[14] = 0;
	mT[15] = 1;
	
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );
}

function d3d_transform_add_rotation_x()
{
	/// @description d3d - Sets the transformation to a rotation around the x-axis with the indicated amount.
	/// @param angle the angle to rotate
	
	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);
	
	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[5] = c;
	mT[6] = -s;
	
	mT[9] = s;
	mT[10] = c;
	
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );
}

function d3d_transform_add_rotation_y()
{
	/// @description d3d - Adds a rotation around the y-axis with the indicated amount.
	/// @param angle the angle to rotate
	
	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);
	
	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[0] = c;
	mT[2] = s;
	
	mT[8] = -s;
	mT[10] = c;
	
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );

}

function d3d_transform_add_rotation_z()
{
	/// @description d3d - Adds a rotation around the z-axis with the indicated amount.
	/// @param angle the angle to rorate the transform through the vector
	
	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);
	
	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[0] = c;
	mT[1] = -s;
	
	mT[4] = s;
	mT[5] = c;
	
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );

}

function d3d_transform_add_scaling()
{
	/// @description d3d - Sets the transformation to a scaling with the indicated amounts.
	/// @param xs the x scale amount
	/// @param ys the y scale amount
	/// @param zs the z scale amount
	
	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[0] = argument0;
	mT[5] = argument1;
	mT[10] = argument2;
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );
	

}

function d3d_transform_add_translation()
{
	/// @description d3d - Sets the transformation to a translation over the indicated vector.
	/// @param xt x value
	/// @param yt y value
	/// @param zt z value
	
	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[12] = argument0;
	mT[13] = argument1;
	mT[14] = argument2;
	
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );

}

function d3d_transform_set_identity()
{
	/// @description d3d - set transform identiy matrix
	
	var i = matrix_build_identity();
	matrix_set( matrix_world, i)

}

function d3d_transform_set_rotation_axis()
{
	/// @description d3d - Sets the transformation to a rotation around the axis indicated by the vector with the indicated amount.
	/// @param xa the x component of the transform vector
	/// @param ya the y component of the transform vector
	/// @param za the z component of the transform vector
	/// @param angle the angle to rotate the transform through the vector
	
	// get the sin and cos of the angle passed in
	var c = dcos(-argument3);
	var s = dsin(-argument3);
	var omc = 1 - c;
	
	// normalise the input vector
	var xx = argument0;
	var yy = argument1;
	var zz = argument2;
	var length2 = sqr(xx) + sqr(yy) + sqr(zz);
	var length = sqrt(length2);
	xx /= length;
	yy /= length;
	zz /= length;
	
	// build the rotation matrix
	var m;
	m[0] = omc * xx * xx + c;
	m[1] = omc * xx * yy + s * zz;
	m[2] = omc * xx * zz - s * yy;
	m[3] = 0;
	
	m[4] = omc * xx * yy - s * zz;
	m[5] = omc * yy * yy + c;
	m[6] = omc * yy * zz + s * xx;
	m[7] = 0;
	
	m[8] = omc * xx * zz + s * yy;
	m[9] = omc * yy * zz - s * xx;
	m[10] = omc * zz * zz + c;
	m[11] = 0;
	
	m[12] = 0;
	m[13] = 0;
	m[14] = 0;
	m[15] = 1;
	
	matrix_set( matrix_world, m);

}

function d3d_transform_set_rotation_x()
{
	/// @description d3d - Sets the transformation to a rotation around the x-axis with the indicated amount.
	/// @param angle the angle to rotate
	
	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);
	
	// build the rotation matrix
	var m = matrix_build_identity();
	m[5] = c;
	m[6] = -s;
	
	m[9] = s;
	m[10] = c;
	
	matrix_set( matrix_world, m);

}

function d3d_transform_set_rotation_y()
{
	/// @description d3d - Sets the transformation to a rotation around the y-axis with the indicated amount.
	/// @param angle the angle to rotate
	
	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);
	
	// build the rotation matrix
	var m = matrix_build_identity();
	m[0] = c;
	m[2] = s;
	
	m[8] = -s;
	m[10] = c;
	
	matrix_set( matrix_world, m);

}

function d3d_transform_set_rotation_z()
{
	/// @description d3d - Sets the transformation to a rotation around the z-axis with the indicated amount.
	/// @param angle the angle to rorate the transform through the vector
	
	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);
	
	// build the rotation matrix
	var m = matrix_build_identity();
	m[0] = c;
	m[1] = -s;
	
	m[4] = s;
	m[5] = c;
	
	matrix_set( matrix_world, m);

}

function d3d_transform_set_scaling()
{
	/// @description d3d - Sets the transformation to a scaling with the indicated amounts.
	/// @param xs the x scale amount
	/// @param ys the y scale amount
	/// @param zs the z scale amount
	
	// build the rotation matrix
	var m = matrix_build_identity();
	m[0] = argument0;
	m[5] = argument1;
	m[10] = argument2;
	matrix_set( matrix_world, m);

}

function d3d_transform_set_translation()
{
	/// @description d3d - Sets the transformation to a translation over the indicated vector.
	/// @param xt x value
	/// @param yt y value
	/// @param zt z value
	
	// build the rotation matrix
	var m = matrix_build_identity();
	m[12] = argument0;
	m[13] = argument1;
	m[14] = argument2;
	matrix_set( matrix_world, m);

}

function d3d_transform_stack_clear()
{
	/// @description d3d - Clears the stack of transformations.
	matrix_stack_clear();
}

function d3d_transform_stack_discard()
{
	/// @description d3d - Removes the top transformation from the stack.
	matrix_stack_pop();
}

function d3d_transform_stack_empty()
{
	/// @description d3d - Returns whether the transformation stack is empty.
	return matrix_stack_is_empty();
}

function d3d_transform_stack_pop()
{
	/// @description d3d - Pops the top transformation from the stack and makes it the current one.
	var m = matrix_stack_top();
	matrix_stack_pop();
	matrix_set( matrix_world, m);

}

function d3d_transform_stack_push()
{
	/// @description d3d - Pushes the current transformation onto the stack.
	var m = matrix_get( matrix_world );
	matrix_stack_push();
	matrix_stack_set( m );
	return true;
}

function d3d_transform_stack_top()
{
	/// @description d3d - Makes the top transformation the current one.
	var m = matrix_stack_top();
	matrix_set( matrix_world, m);

}

function d3d_transform_vertex()
{
	/// @description d3d - Sets the transformation to a scaling with the indicated amounts.
	/// @param xs the x scale amount
	/// @param ys the y scale amount
	/// @param zs the z scale amount
	var m = matrix_get( matrix_world );
	return matrix_transform_vertex( m, argument0, argument1, argument2 );
}

function d3d_vertex()
{
	/// @description d3d - Sets the primitive vertex
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha());
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );
	
	
	

}

function d3d_vertex_color()
{
	/// @description d3d - Sets the primitive vertex and colour
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument3, argument4 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );
	
	
	

}

function d3d_vertex_colour()
{
	/// @description d3d - Sets the primitive vertex and colour
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument3, argument4 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );
	
	

}

function d3d_vertex_normal()
{
	/// @description d3d - Sets the primitive vertex and normal
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param nx the normal x
	/// @param ny the normal y
	/// @param nz the normal z
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha() );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );
	
	

}

function d3d_vertex_normal_color()
{
	/// @description d3d - Sets the primitive vertex and normal
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param nx the normal x
	/// @param ny the normal y
	/// @param nz the normal z
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument6, argument7 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );
	
	

}

function d3d_vertex_normal_colour()
{
	/// @description d3d - Sets the primitive vertex and normal
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param nx the normal x
	/// @param ny the normal y
	/// @param nz the normal z
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument6, argument7 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );
	
	

}

function d3d_vertex_normal_texture()
{
	/// @description d3d - Defines a vertex for a textured primitive in 3D along with its corresponding normal.
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param nx the normal x
	/// @param ny the normal y
	/// @param nz the normal z
	/// @param u the normal u
	/// @param v the normal v
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha() );
	vertex_texcoord( global.__d3dPrimBuffer, (argument6 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument7 * global.__d3dPrimTexH) + global.__d3dPrimTexY );
}

function d3d_vertex_normal_texture_color()
{
	/// @description d3d - Sets the primitive vertex and normal
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param nx the normal x
	/// @param ny the normal y
	/// @param nz the normal z
	/// @param u the normal u
	/// @param v the normal v
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument8, argument9 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument6 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument7 * global.__d3dPrimTexH) + global.__d3dPrimTexY );
	
	

}

function d3d_vertex_normal_texture_colour()
{
	/// @description d3d - Sets the primitive vertex and normal
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param nx the normal x
	/// @param ny the normal y
	/// @param nz the normal z
	/// @param u the normal u
	/// @param v the normal v
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument8, argument9 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument6 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument7 * global.__d3dPrimTexH) + global.__d3dPrimTexY );
	
	

}

function d3d_vertex_texture()
{
	/// @description d3d - Sets the primitive vertex
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param u the normal u
	/// @param v the normal v
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha() );
	vertex_texcoord( global.__d3dPrimBuffer, (argument3 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument4 * global.__d3dPrimTexH) + global.__d3dPrimTexY );
	
	

}

function d3d_vertex_texture_color()
{
	/// @description d3d - Sets the primitive vertex
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param u the normal u
	/// @param v the normal v
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument5, argument6 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument3 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument4 * global.__d3dPrimTexH) + global.__d3dPrimTexY );
	
	

}

function d3d_vertex_texture_colour()
{
	/// @description d3d - Sets the primitive vertex
	/// @param x the x position
	/// @param y the y position
	/// @param z the z position
	/// @param u the normal u
	/// @param v the normal v
	/// @param col the colour
	/// @param alpha the alpha
	
	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument5, argument6 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument3 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument4 * global.__d3dPrimTexH) + global.__d3dPrimTexY );
	
	

}

function __d3d_model_add_vertex()
{
	
		var m = argument0;
		var i = e__YYM.TriB;
		var uv_i = e__YYM.TriUVB;
		var colarrayi = e__YYM.TriCols;
		var colnum = e__YYM.NumTriCols;
		switch(m[e__YYM.PrimKind])
		{
		case pr_pointlist:
			i = e__YYM.PointB;
			uv_i = e__YYM.PointUVB;
			colarrayi = e__YYM.PointCols;
			colnum = e__YYM.NumPointCols;
			break;
		case pr_linelist:
		case pr_linestrip:
			i = e__YYM.LineB;
			uv_i = e__YYM.LineUVB;
			colarrayi = e__YYM.LineCols;
			colnum = e__YYM.NumLineCols;
			break;
		}
	
		var colarray = m[colarrayi];
	
		// create the buffer if we need to
		var b = m[i];
		if (b == undefined) {
			b = buffer_create( 36, buffer_grow, 1 );
			m[@i] = b;
		} // end if
	
		// create the uv buffer if we need to
		var uvb = m[uv_i];
		if (uvb == undefined)
		{
			uvb = buffer_create(8, buffer_grow, 1);
			m[@uv_i] = uvb;
		}
	
		var globalcol = false;
		if (argument7 == $00010000)
		{
			globalcol = true;
		}
	
		// add the vertex in
		var c = m[e__YYM.NumVerts];
		switch(m[e__YYM.PrimKind])
		{
		case pr_pointlist:
		case pr_linelist:
		case pr_trianglelist:
			buffer_write( b, buffer_f32, argument1 );		// x
			buffer_write( b, buffer_f32, argument2 );		// y
			buffer_write( b, buffer_f32, argument3 );		// z
			buffer_write( b, buffer_f32, argument4 );		// nx
			buffer_write( b, buffer_f32, argument5 );		// ny
			buffer_write( b, buffer_f32, argument6 );		// nz
			buffer_write( b, buffer_u32, argument7 );		// colour
			buffer_write( b, buffer_f32, argument8 );		// u
			buffer_write( b, buffer_f32, argument9 );		// v		
		
			buffer_write( uvb, buffer_f32, argument8 );
			buffer_write( uvb, buffer_f32, argument9 );
			++c;
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}
			break;
		case pr_linestrip:
			// add the previous if we are on vertex 1 or above
			if (c >= 2) {
				buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
				buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
				buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
				buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
				buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
				buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
				buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
				buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
				buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
			
				buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
				buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );	
				++c;
			
				if (globalcol)
				{
					colarray[ m[colnum]] = buffer_tell(b) - 12;
					m[@ colnum]++;
				}
			} // end if	
		
			m[@ e__YYM.V1X ] = argument1;
			m[@ e__YYM.V1Y ] = argument2;
			m[@ e__YYM.V1Z ] = argument3;
			m[@ e__YYM.V1NX ] = argument4;
			m[@ e__YYM.V1NY ] = argument5;
			m[@ e__YYM.V1NZ ] = argument6;
			m[@ e__YYM.V1C ] = argument7;
			m[@ e__YYM.V1U ] = argument8;
			m[@ e__YYM.V1V ] = argument9;
		
			buffer_write( b, buffer_f32, argument1 );		// x
			buffer_write( b, buffer_f32, argument2 );		// y
			buffer_write( b, buffer_f32, argument3 );		// z
			buffer_write( b, buffer_f32, argument4 );		// nx
			buffer_write( b, buffer_f32, argument5 );		// ny
			buffer_write( b, buffer_f32, argument6 );		// nz
			buffer_write( b, buffer_u32, argument7 );		// colour
			buffer_write( b, buffer_f32, argument8 );		// u
			buffer_write( b, buffer_f32, argument9 );		// v	
		
			buffer_write( uvb, buffer_f32, argument8 );
			buffer_write( uvb, buffer_f32, argument9 );
			++c;
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}	
			break;
		case pr_trianglestrip:
			// add the previous if we are on vertex 1 or above
			var flip = ((c & 1) == 1) ? true : false;
			if (c >= 3) {
				if (flip)
				{						
					buffer_write( b, buffer_f32, m[ e__YYM.V2X ] );		// x
					buffer_write( b, buffer_f32, m[ e__YYM.V2Y ] );		// y
					buffer_write( b, buffer_f32, m[ e__YYM.V2Z ] );		// z
					buffer_write( b, buffer_f32, m[ e__YYM.V2NX ] );	// nx
					buffer_write( b, buffer_f32, m[ e__YYM.V2NY ] );	// ny
					buffer_write( b, buffer_f32, m[ e__YYM.V2NZ ] );	// nz
					buffer_write( b, buffer_u32, m[ e__YYM.V2C ] );		// colour
					buffer_write( b, buffer_f32, m[ e__YYM.V2U ] );		// u
					buffer_write( b, buffer_f32, m[ e__YYM.V2V ] );		// v
			
					buffer_write( uvb, buffer_f32, m[ e__YYM.V2U ] );
					buffer_write( uvb, buffer_f32, m[ e__YYM.V2V ] );
					++c;
					
					buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
					buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
					buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
					buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
					buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
					buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
					buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
					buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
					buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
			
					buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
					buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );
					++c;
				}
				else
				{
					buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
					buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
					buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
					buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
					buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
					buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
					buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
					buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
					buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
			
					buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
					buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );
					++c;
			
					buffer_write( b, buffer_f32, m[ e__YYM.V2X ] );		// x
					buffer_write( b, buffer_f32, m[ e__YYM.V2Y ] );		// y
					buffer_write( b, buffer_f32, m[ e__YYM.V2Z ] );		// z
					buffer_write( b, buffer_f32, m[ e__YYM.V2NX ] );	// nx
					buffer_write( b, buffer_f32, m[ e__YYM.V2NY ] );	// ny
					buffer_write( b, buffer_f32, m[ e__YYM.V2NZ ] );	// nz
					buffer_write( b, buffer_u32, m[ e__YYM.V2C ] );		// colour
					buffer_write( b, buffer_f32, m[ e__YYM.V2U ] );		// u
					buffer_write( b, buffer_f32, m[ e__YYM.V2V ] );		// v
			
					buffer_write( uvb, buffer_f32, m[ e__YYM.V2U ] );
					buffer_write( uvb, buffer_f32, m[ e__YYM.V2V ] );
					++c;
				}					
			
				if (globalcol)
				{
					colarray[ m[colnum]] = buffer_tell(b) - (12 + 36) ;
					m[@ colnum]++;
				
					colarray[ m[colnum]] = buffer_tell(b) - 12;
					m[@ colnum]++;
				}	
			} // end if	
		
			m[@ e__YYM.V1X ] = m[ e__YYM.V2X ];
			m[@ e__YYM.V1Y ] = m[ e__YYM.V2Y ];
			m[@ e__YYM.V1Z ] = m[ e__YYM.V2Z ];
			m[@ e__YYM.V1NX ] = m[ e__YYM.V2NX ];
			m[@ e__YYM.V1NY ] = m[ e__YYM.V2NY ];
			m[@ e__YYM.V1NZ ] = m[ e__YYM.V2NZ ];
			m[@ e__YYM.V1C ] = m[ e__YYM.V2C ];
			m[@ e__YYM.V1U ] = m[ e__YYM.V2U ];
			m[@ e__YYM.V1V ] = m[ e__YYM.V2V ];
		
			m[@ e__YYM.V2X ] = argument1;
			m[@ e__YYM.V2Y ] = argument2;
			m[@ e__YYM.V2Z ] = argument3;
			m[@ e__YYM.V2NX ] = argument4;
			m[@ e__YYM.V2NY ] = argument5;
			m[@ e__YYM.V2NZ ] = argument6;
			m[@ e__YYM.V2C ] = argument7;
			m[@ e__YYM.V2U ] = argument8;
			m[@ e__YYM.V2V ] = argument9;
		
			buffer_write( b, buffer_f32, argument1 );		// x
			buffer_write( b, buffer_f32, argument2 );		// y
			buffer_write( b, buffer_f32, argument3 );		// z
			buffer_write( b, buffer_f32, argument4 );		// nx
			buffer_write( b, buffer_f32, argument5 );		// ny
			buffer_write( b, buffer_f32, argument6 );		// nz
			buffer_write( b, buffer_u32, argument7 );		// colour
			buffer_write( b, buffer_f32, argument8 );		// u
			buffer_write( b, buffer_f32, argument9 );		// v
		
			buffer_write( uvb, buffer_f32, argument8 );
			buffer_write( uvb, buffer_f32, argument9 );
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}	
			++c;
			break;
		case pr_trianglefan:
			if (c==0) {
				m[@ e__YYM.V1X ] = argument1;
				m[@ e__YYM.V1Y ] = argument2;
				m[@ e__YYM.V1Z ] = argument3;
				m[@ e__YYM.V1NX ] = argument4;
				m[@ e__YYM.V1NY ] = argument5;
				m[@ e__YYM.V1NZ ] = argument6;
				m[@ e__YYM.V1C ] = argument7;
				m[@ e__YYM.V1U ] = argument8;
				m[@ e__YYM.V1V ] = argument9;
			} // end if
		
			if (c >= 3) {
				buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
				buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
				buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
				buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
				buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
				buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
				buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
				buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
				buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
			
				buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
				buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );
				++c;
			
				buffer_write( b, buffer_f32, m[ e__YYM.V2X ] );		// x
				buffer_write( b, buffer_f32, m[ e__YYM.V2Y ] );		// y
				buffer_write( b, buffer_f32, m[ e__YYM.V2Z ] );		// z
				buffer_write( b, buffer_f32, m[ e__YYM.V2NX ] );	// nx
				buffer_write( b, buffer_f32, m[ e__YYM.V2NY ] );	// ny
				buffer_write( b, buffer_f32, m[ e__YYM.V2NZ ] );	// nz
				buffer_write( b, buffer_u32, m[ e__YYM.V2C ] );		// colour
				buffer_write( b, buffer_f32, m[ e__YYM.V2U ] );		// u
				buffer_write( b, buffer_f32, m[ e__YYM.V2V ] );		// v
			
				buffer_write( uvb, buffer_f32, m[ e__YYM.V2U ] );
				buffer_write( uvb, buffer_f32, m[ e__YYM.V2V ] );
				++c;
			
				if (globalcol)
				{
					colarray[ m[colnum]] = buffer_tell(b) - (12 + 36) ;
					m[@ colnum]++;
				
					colarray[ m[colnum]] = buffer_tell(b) - 12;
					m[@ colnum]++;
				}	
			} // end if	
		
			m[@ e__YYM.V2X ] = argument1;
			m[@ e__YYM.V2Y ] = argument2;
			m[@ e__YYM.V2Z ] = argument3;
			m[@ e__YYM.V2NX ] = argument4;
			m[@ e__YYM.V2NY ] = argument5;
			m[@ e__YYM.V2NZ ] = argument6;
			m[@ e__YYM.V2C ] = argument7;
			m[@ e__YYM.V2U ] = argument8;
			m[@ e__YYM.V2V ] = argument9;
		
			buffer_write( b, buffer_f32, argument1 );		// x
			buffer_write( b, buffer_f32, argument2 );		// y
			buffer_write( b, buffer_f32, argument3 );		// z
			buffer_write( b, buffer_f32, argument4 );		// nx
			buffer_write( b, buffer_f32, argument5 );		// ny
			buffer_write( b, buffer_f32, argument6 );		// nz
			buffer_write( b, buffer_u32, argument7 );		// colour
			buffer_write( b, buffer_f32, argument8 );		// u
			buffer_write( b, buffer_f32, argument9 );		// v
		
			buffer_write( uvb, buffer_f32, argument8 );
			buffer_write( uvb, buffer_f32, argument9 );
			++c;
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}	
			break;
		} 
		m[@ e__YYM.NumVerts ] = c;
		m[@ colarrayi] = colarray;	// this is probably super-bad - may switch over to using buffers for the colour offset tables rather than arrays to avoid copies
}

function __init_d3d()
{
	gml_pragma( "global", "__init_d3d();");
	// setup the depth variable to a sensible default
	global.__d3d=false;
	global.__d3dDepth=0;
	global.__d3dCamera=camera_create();
	global.__d3dPrimKind = -1;
	global.__d3dPrimTex = -1;
	global.__d3dPrimBuffer=vertex_create_buffer();
	vertex_format_begin();
		vertex_format_add_position_3d();
		vertex_format_add_normal();
		vertex_format_add_colour();
		vertex_format_add_texcoord(); 
	global.__d3dPrimVF=vertex_format_end();
	global.__d3dDeprecatedMessage = [ false ];
	
	enum e__YYM
	{
		PointB,
		LineB,
		TriB,
		PointUVB,
		LineUVB,
		TriUVB,
		PointVB,
		LineVB,
		TriVB,
		Texture,
		Colour,
		NumVerts,
		PrimKind,
		NumPointCols,
		NumLineCols,
		NumTriCols,
		PointCols,
		LineCols,
		TriCols,
	
		// these are used when building model primitives
		V1X,
		V1Y,
		V1Z,
		V1NX,
		V1NY,
		V1NZ,
		V1C,
		V1U,
		V1V,
	
		V2X,
		V2Y,
		V2Z,
		V2NX,
		V2NY,
		V2NZ,
		V2C,
		V2U,
		V2V,
	};
	
	enum e__YYMKIND
	{
		PRIMITIVE_BEGIN,
		PRIMITIVE_END,
		VERTEX,
		VERTEX_COLOR,
		VERTEX_TEX,
		VERTEX_TEX_COLOR,
		VERTEX_N,
		VERTEX_N_COLOR,
		VERTEX_N_TEX,
		VERTEX_N_TEX_COLOR,
		SHAPE_BLOCK,
		SHAPE_CYLINDER,
		SHAPE_CONE,
		SHAPE_ELLIPSOID,
		SHAPE_WALL,
		SHAPE_FLOOR,
	};

}

#endregion
#region background

function background_add()
{
	/// @description Adds an image from a file to the set of background resources.
	/// @param fname The name (string) of the file to add.
	/// @param removeback Indicates whether to make all pixels with the selected colour (left-bottom pixel) transparent.
	/// @param smooth Indicates whether to smooth the edges if transparent.
	/// @returns {number} resource name for the new background
	
	return sprite_add(argument0, 0, argument1, argument2, 0, 0);
}

function background_add_alpha()
{
	/// @description Adds an image (with alpha) from a file to the set of background resources.
	/// @param fname The name (string) of the file to add.
	/// @returns {number} resource name for the new background
	var __dummy = argument1;
	return sprite_add(argument0, 0, false, false, 0, 0);

}

function background_assign()
{
	/// @description Assigns one background to another background index.
	/// @param index The index of the background to be copied to (ie: over-written).
	/// @param background The background to be copied from.
	/// @returns
	
	sprite_assign(argument0, argument1);
}

function background_create_color()
{
	/// @description Creates a new background of a given size and colour.
	/// @param w The width of the background.
	/// @param h The height of the background.
	/// @param col The colour to clear the background to.
	/// @returns {number} resource name for the new background
	
	// First-pass implementation - may need to add engine support if this causes problems
	var __w = argument0;
	var __h = argument1;
	var __col = argument2;
	
	var __CompTempSurf = surface_create(__w, __h);
	if (surface_exists(__CompTempSurf))
	{
		surface_set_target(__CompTempSurf);
		draw_clear(__col);
		surface_reset_target();
		
		var __sprid = sprite_create_from_surface(__CompTempSurf, 0, 0, __w, __h, false, false, 0, 0);
		surface_free(__CompTempSurf);
		return __sprid;
	}
	else
	{
		return -1;
	}

}

function background_create_colour()
{
	/// @description Creates a new background of a given size and colour.
	/// @param w The width of the background.
	/// @param h The height of the background.
	/// @param col The colour to clear the background to.
	/// @returns {number} resource name for the new background
	
	// First-pass implementation - may need to add engine support if this causes problems
	var __w = argument0;
	var __h = argument1;
	var __col = argument2;
	
	var __CompTempSurf = surface_create(__w, __h);
	if (surface_exists(__CompTempSurf))
	{
		surface_set_target(__CompTempSurf);
		draw_clear(__col);
		surface_reset_target();
		
		var __sprid = sprite_create_from_surface(__CompTempSurf, 0, 0, __w, __h, false, false, 0, 0);
		surface_free(__CompTempSurf);
		return __sprid;
	}
	else
	{
		return -1;
	}

}

function background_create_from_surface()
{
	/// @description Creates a background by copying an area from a surface.
	/// @param index The index of the surface to create from.
	/// @param x The x position to copy from.
	/// @param y The y position to copy from.
	/// @param w The width of the area to be copied (from the x position).
	/// @param h The height of the area to be copied (from the y position).
	/// @param removeback Indicates whether to make all pixels with the same colour (left-bottom pixel) transparent.
	/// @param smooth Indicates whether to smooth the edges.
	/// @returns {number} resource name for the new background
	
	return sprite_create_from_surface(argument0, argument1, argument2, argument3, argument4, argument5, argument6, 0, 0);
}

function background_create_gradient()
{
	/// @description Creates a new background with a coloured gradient.
	/// @param w The width of the new background.
	/// @param h The height of the new background.
	/// @param colour1 The first colour of the gradient.
	/// @param colour2 The second colour of the gradient.
	/// @param kind  The type of gradient (0 - 5). 
	/// @returns {number} resource name for the new background
	
	// First-pass implementation - may need to add engine support if this causes problems
	var __w = argument0;
	var __h = argument1;
	var __col1 = argument2;
	var __col2 = argument3;
	var __kind = argument4;
	
	var __halfw = __w / 2;
	var __halfh = __h / 2;
	
	var __CompTempSurf = surface_create(__w, __h);
	if (surface_exists(__CompTempSurf))
	{
		surface_set_target(__CompTempSurf);
		
		switch(__kind)
		{
			case 0:
			{
				// Horizontal gradient
				draw_rectangle_colour(0, 0, __w, __h, __col1, __col2, __col2, __col1, false);
			} break;
			
			case 1:
			{
				// Vertical gradient
				draw_rectangle_colour(0, 0, __w, __h, __col2, __col2, __col1, __col1, false);
			} break;
			
			case 2:
			{
				// Rectangular gradient			
				// Can't just use four rectangles due to triangulation artifacts
				// Also can't use a triangle fan because they aren't supported on all platforms			
				draw_primitive_begin(pr_trianglelist);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(0, __halfh, __col2, 1);
				draw_vertex_colour(0, 0, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(0, 0, __col2, 1);
				draw_vertex_colour(__halfw, 0, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__halfw, 0, __col2, 1);
				draw_vertex_colour(__w, 0, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__w, 0, __col2, 1);
				draw_vertex_colour(__w, __halfh, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__w, __halfh, __col2, 1);
				draw_vertex_colour(__w, __h, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__w, __h, __col2, 1);
				draw_vertex_colour(__halfw, __h, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__halfw, __h, __col2, 1);
				draw_vertex_colour(0, __h, __col2, 1);
				
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(0, __h, __col2, 1);
				draw_vertex_colour(0, __halfh, __col2, 1);
				
				draw_primitive_end();
			} break;
			
			case 3:
			{
				// Elliptical gradient
				draw_clear(__col2);			
				draw_ellipse_colour(0, 0, __w, __h, __col1, __col2, false);
			} break;
			
			case 4:
			{
				// Symmetrical horizontal gradient
				draw_rectangle_colour(0, 0, __halfw, __h, __col2, __col1, __col1, __col2, false);
				draw_rectangle_colour(__halfw, 0, __w, __h, __col1, __col2, __col2, __col1, false);
			} break;
			
			case 5:
			{
				// Symmetrical vertical gradient
				draw_rectangle_colour(0, 0, __w, __halfh, __col2, __col2, __col1, __col1, false);
				draw_rectangle_colour(0, __halfh, __w, __h, __col1, __col1, __col2, __col2, false);
			} break;
		}
		
		surface_reset_target();
		
		var __sprid = sprite_create_from_surface(__CompTempSurf, 0, 0, __w, __h, false, false, 0, 0);
		surface_free(__CompTempSurf);
		return __sprid;
	}
	else
	{
		return -1;
	}

}

function background_delete()
{
	/// @description Deletes the background from memory, freeing the memory used.
	/// @param index The index of the background to be deleted.
	/// @returns 
	
	sprite_delete(argument0);
}

function background_duplicate()
{
	/// @description Creates a duplicate of the background with the given index.
	/// @param index The index of the background to duplicate.
	/// @returns {number} resource name for the new background
	
	return sprite_duplicate(argument0);
}

function background_exists()
{
	/// @description Determines whether a background exists or not.
	/// @param index The index of the background to check.
	/// @returns {boolean} whether the background exists or not
	
	return sprite_exists(argument0);
}

function background_get_height()
{
	/// @description Finds the height of a background.
	/// @param index The index of the background to find the height of.
	/// @returns {number} the height of the background
	
	return sprite_get_height(argument0);
}

function background_get_name()
{
	/// @description Gets the name of a background.
	/// @param index The background image asset to get the name of.
	/// @returns {string} the name of the background
	
	return sprite_get_name(argument0);
}

function background_get_preload()
{
	/// @description Gets whether a background is preloaded
	/// @param index The background image asset.
	/// @returns {boolean} the preload status
	
	return false;
}

function background_get_smooth()
{
	/// @description Gets whether a background is smooth
	/// @param index The background image asset.
	/// @returns {boolean} whether the background is smooth
	
	return false;
}

function background_get_texture()
{
	/// @description Returns the texture id for the given background.
	/// @param back The index of the background to use.
	/// @returns {pointer} a pointer to the background texture
	
	return sprite_get_texture(argument0, 0);
}

function background_get_transparent()
{
	/// @description Gets whether a background is transparent
	/// @param index The background image asset.
	/// @returns {boolean} whether the background is transparent
	
	return false;
}

function background_get_uvs()
{
	/// @description Returns the texture coordinates of the background within the texture page as an array.
	/// @param back The index of the background to use.
	/// @returns {array} an array containing the uv coordinates of the background on the texture page
	
	return sprite_get_uvs(argument0, 0);
}

function background_get_width()
{
	/// @description Finds the width of a background.
	/// @param index The index of the background to find the width of.
	/// @returns {number} the width of the background
	
	return sprite_get_width(argument0);
}

function background_name()
{
	/// @description Gets the name of a background.
	/// @param index The background image asset to get the name of.
	/// @returns {string} the name of the background
	
	return sprite_get_name(argument0);
}

function background_prefetch()
{
	/// @description Prefetches the specified background
	/// @param back The index of the background to prefetch.
	/// @returns 
	
	sprite_prefetch(argument0);
}

function background_prefetch_multi()
{
	/// @description Prefetches the specified backgrounds
	/// @param back_array An array of backgrounds to prefetch
	/// @returns 
	
	sprite_prefetch_multi(argument0);
}

function background_replace()
{
	/// @description Replace a background resource with another one.
	/// @param ind The index of the background to permanently replace.
	/// @param fname The filename of the image to make the new background.
	/// @param removeback Indicates whether to make all pixels with the same colour (left-bottom pixel) transparent.
	/// @param smooth Indicates whether to smooth the edges.
	/// @returns 
	
	sprite_replace(argument0, argument1, 1, argument2, argument3, 0, 0);
}

function background_replace_alpha()
{
	/// @description Replace a background resource with another one.
	/// @param ind The index of the background to permanently replace.
	/// @param fname The filename of the image to make the new background.
	/// @param preload Indicates whether to make all pixels with the same colour (left-bottom pixel) transparent.
	/// @returns 
	
	sprite_replace(argument0, argument1, 1, false, false, 0, 0);
}

function background_save()
{
	/// @description Save a background to disc.
	/// @param back The index of the background to save.
	/// @param fname The filename for the saved background.
	/// @returns 
	
	sprite_save(argument0, 0, argument1);
}

function background_set_alpha_from_background()
{
	/// @description Changes the alpha (transparency) of one given background based on the intensity/value map of another.
	/// @param ind The index of the background to change the transparency map of.
	/// @param back The index of the background to take the transparency map data from.
	/// @returns 
	
	sprite_set_alpha_from_sprite(argument0, argument1);
}

function draw_background()
{
	/// @description Draw a background without colour blending or transparency
	/// @param back The index of the background to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @returns 
	
	draw_sprite(argument0, 0, argument1, argument2);
}

function draw_background_ext()
{
	/// @description Draws a background at a given position, with customizable scaling, rotation, blend and alpha.
	/// @param back The index of the background to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @param xscale The horizontal scaling of the background.
	/// @param yscale The vertical scaling of the background.
	/// @param rot The rotation of the background.
	/// @param colour The colour with which to blend the background (use -1 or c_white to display it normally).
	/// @param alpha  The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque). 
	/// @returns 
	
	draw_sprite_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6, argument7);
}

function draw_background_general()
{
	/// @description Draws part of a background at a given position with scaling, rotating, four-corner blending and alpha options.
	/// @param back The index of the background to draw.
	/// @param left The x position on the background of the top left corner of the area to draw.
	/// @param top  The y position on the background of the top left corner of the area to draw.
	/// @param width  The width of the area to draw.
	/// @param height  The height of the area to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @param xscale The horizontal scaling of the background.
	/// @param yscale The vertical scaling of the background.
	/// @param rot The rotation of the background.
	/// @param c1 The colour with which to blend the top left area of the background. 
	/// @param c2 The colour with which to blend the top right area of the background.
	/// @param c3 The colour with which to blend the bottom right area of the background.
	/// @param c4  The colour with which to blend the bottom left area of the background. 
	/// @param alpha  The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque). 
	/// @returns 
	
	draw_sprite_general(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11, argument12, argument13, argument14);
}

function draw_background_part()
{
	/// @description Draws part of a background at a given position.
	/// @param back The index of the background to draw.
	/// @param left The x position on the background of the top left corner of the area to draw.
	/// @param top  The y position on the background of the top left corner of the area to draw.
	/// @param width  The width of the area to draw.
	/// @param height  The height of the area to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @returns 
	
	draw_sprite_part(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6);
}

function draw_background_part_ext()
{
	/// @description Draws part of a background at a given position with scaling, blending and alpha options.
	/// @param back The index of the background to draw.
	/// @param left The x position on the background of the top left corner of the area to draw.
	/// @param top  The y position on the background of the top left corner of the area to draw.
	/// @param width  The width of the area to draw.
	/// @param height  The height of the area to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @param xscale  The horizontal scaling of the background.
	/// @param yscale  The vertical scaling of the background.
	/// @param colour   The colour with which to blend the background (use -1 or c_white to display it normally). 
	/// @param alpha  The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque).
	/// @returns 
	
	draw_sprite_part_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10);
}

function draw_background_stretched()
{
	/// @description Draws a background at a given position, stretched.
	/// @param back The index of the background to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @param w The width of the area the stretched background will occupy.
	/// @param h The height of the area the stretched background will occupy.
	/// @returns 
	
	draw_sprite_stretched(argument0, 0, argument1, argument2, argument3, argument4);
}

function draw_background_stretched_ext()
{
	/// @description Draws a background at a given position, stretched, and allows for a custom blend and alpha.
	/// @param back The index of the background to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @param w The width of the area the stretched background will occupy.
	/// @param h The height of the area the stretched background will occupy.
	/// @param colour The colour with which to blend the background (use -1 or c_white to display it normally).
	/// @param alpha The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque).
	/// @returns 
	
	draw_sprite_stretched_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6);
}

function draw_background_tiled()
{
	/// @description Draws a background at a given position, and tiles it to fill the entire view.
	/// @param back The index of the background to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @returns 
	
	draw_sprite_tiled(argument0, 0, argument1, argument2);
}

function draw_background_tiled_ext()
{
	/// @description Draws a background at a given position with scaling, blending and alpha, and tiles it to fill the entire view.
	/// @param back The index of the background to draw.
	/// @param x The x coordinate of where to draw the background.
	/// @param y The y coordinate of where to draw the background.
	/// @param xscale The horizontal scaling of the background.
	/// @param yscale The vertical scaling of the background.
	/// @param colour The colour with which to blend the background (use -1 or c_white to display it normally).
	/// @param alpha The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque).
	/// @returns 
	
	draw_sprite_tiled_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6);
}

function room_set_background()
{
	/// @description Sets a background and its related attributes of a given room.
	/// @param ind The index of the room to set the background of.
	/// @param bind The index of the background 'slot' to set (between 0 and 7).
	/// @param vis Whether the new background is visible (true) or not (false).
	/// @param fore Whether the background is actually a foreground (true) or a background (false).
	/// @param back The index of the new background.
	/// @param x The x position of the background (if htiled is true, the x of one of the backgrounds).
	/// @param y The y position of the background (if vtiled is true, the y of one of the backgrounds).
	/// @param htiled Whether the background is tiled horizontally (true) or not (false).
	/// @param vtiled Whether the background is tiled vertically (true) or not (false).
	/// @param hspeed The horizontal speed of the background in pixels per step.
	/// @param vspeed The vertical speed of the background in pixels per step.
	/// @param alpha The alpha (transparency) of the background. 1=opaque, 0=invisible, 0.5=translucent etc
	/// @returns 
	
	// NOTE: this script will only work properly if you're using the standard depth range (-16000 to 16000)
	
	var __ind = argument0;
	var __bind = argument1;
	var __vis = argument2;
	var __fore = argument3;
	var __back = argument4;
	var __x = argument5;
	var __y = argument6;
	var __htiled = argument7;
	var __vtiled = argument8;
	var __hspeed = argument9;
	var __vspeed = argument10;
	var __alpha = argument11;
	
	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}
	
	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);
	
	__background_set_element(__bind, __vis, __fore, __back, __x, __y, __htiled, __vtiled, 1,1,false, __hspeed, __vspeed, $ffffff, __alpha);
	
	// Finally, restore our original room target
	layer_set_target_room(__currroom);
}

function __background_get()
{
	var __prop = argument0;
	var __bind = argument1;
	
	var __backinfo = __background_get_element(__bind);
	
	return __background_get_internal(__prop, __bind, __backinfo);

}

function __background_get_colour()
{
	var __colinfo = __background_get_colour_element();
	
	if (__colinfo[0] == -1)
		return 0;
		
	var __col = layer_background_get_blend(__colinfo[0]);
	return __col;
}

function __background_get_colour_element()
{
	// NOTE: this script will only work properly if you're using the standard depth range (-16000 to 16000)
	var __nearestdepth = -15000;
	var __farthestdepth = 15999;
	var __depthinc = 100;
	
	var __result;
	__result[0] = -1;
	__result[1] = -1;
	
	
	// Now look at the existing layers in the room to see if we have any foregrounds or backgrounds
	var __colstring = "Compatibility_Colour";
	var __layerlist = layer_get_all();
	var __layerlistlength = array_length(__layerlist);
	var __i;
	
	var __layerid = -1;
	var __isforeground = false;
	
	// Try and find the appropriate background in the list of layers
	for(__i = 0; __i < __layerlistlength; __i++)
	{
		var __layername = layer_get_name(__layerlist[__i]);	
		if (string_pos(__colstring, __layername) > 0)
		{
			__layerid = __layerlist[__i];		
				
			break;		
		}	
	}
	
	if (__layerid != -1)
	{
		// We have a winner!
		// Get id of background element on this layer
		var __els = layer_get_all_elements(__layerid);
		var __elslength = array_length(__els);
		for(__i = 0; __i < __elslength; __i++)
		{
			if (layer_get_element_type(__els[__i]) == layerelementtype_background)
			{				
				__result[0] = __els[__i];
				__result[1] = __layerid;
			}
		}			
	}
	else
	{
		// Need to construct a new layer with a new background
		var __newback = __background_set_element(-1, false, false, -1, 0, 0, true, true,1,1, true, 0, 0, $0, 1);
		__result[0] = __newback[0];
		__result[1] = __newback[1];	
	}
	
	return __result;
}

function __background_get_element()
{
	var __bind = argument0;
	
	var __result;
	__result[0] = -1;
	__result[1] = -1;
	__result[2] = -1;
	
	
	// Look at the existing layers in the room to see if we have any foregrounds or backgrounds
	var __fgstring = "Compatibility_Foreground_";
	var __bgstring = "Compatibility_Background_";
	var __fglen = string_length(__fgstring);
	var __bglen = string_length(__bgstring);
	var __layerlist = layer_get_all();
	var __layerlistlength = array_length(__layerlist);
	var __i;
	
	var __layerid = -1;
	var __isforeground = false;
	
	// Try and find the appropriate background in the list of layers
	for(__i = 0; __i < __layerlistlength; __i++)
	{
		var __layername = layer_get_name(__layerlist[__i]);	
		if (string_pos(__fgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __fglen + 1);
			if (__slotchr == "")
				continue;
				
			var __slot = real( __slotchr );
			
			if (__slot == __bind)
			{
				__layerid = __layerlist[__i];
				__isforeground = true;
				
				break;
			}		
		}
		else if (string_pos(__bgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __bglen + 1);
			if (__slotchr == "")
				continue;
				
			var __slot = real( __slotchr );
			
			if (__slot == __bind)
			{
				__layerid = __layerlist[__i];
				__isforeground = false;
				
				break;
			}		
		}	
	}
	
	if (__layerid != -1)
	{
		// We have a winner!
		// Get id of background element on this layer
		var __els = layer_get_all_elements(__layerid);
		var __elslength = array_length(__els);
		for(__i = 0; __i < __elslength; __i++)
		{
			if (layer_get_element_type(__els[__i]) == layerelementtype_background)
			{				
				__result[0] = __els[__i];
				__result[1] = __layerid;
				__result[2] = __isforeground;
			}
		}			
	}
	else
	{
		// Need to construct a new layer with a new background
		var __newback = __background_set_element(__bind, false, false, -1, 0, 0, true, true,1,1, false, 0, 0, $ffffff, 1);
		__result[0] = __newback[0];
		__result[1] = __newback[1];
		__result[2] = false;
	}
	
	return __result;
}

function __background_get_internal()
{
	var __prop = argument0;
	var __bind = argument1;
	var __backinfo = argument2;
	
	if ((__backinfo[0] == -1)
		|| (layer_background_exists(__backinfo[1], __backinfo[0]) == false))	// this can happen when we change between backgrounds and foregrounds (because layers and elements get destroyed)
	{
		// Try getting the background info again from the bind index
		__backinfo = __background_get_element(__bind);
	
		if (__backinfo[0] == -1)
			return -1;	// erm
	}
	
	
	
	var __res = -1;
	
	var __backid = __backinfo[0];
	var __layerid = __backinfo[1];
	var __isfore = __backinfo[2];
	
	switch(__prop)
	{
	case e__BG.Visible: __res = layer_get_visible(__layerid); break;
	case e__BG.Foreground: __res = __isfore; break;
	case e__BG.Index: __res = layer_background_get_sprite(__backid)  break;
	case e__BG.X: __res = layer_get_x(__layerid); break;
	case e__BG.Y: __res = layer_get_y(__layerid); break;
	case e__BG.Width: __res = sprite_get_width(layer_background_get_index(__backid)); break;
	case e__BG.Height: __res = sprite_get_height(layer_background_get_index(__backid)); break;
	case e__BG.HTiled: __res = layer_background_get_htiled(__backid); break;
	case e__BG.VTiled: __res = layer_background_get_vtiled(__backid); break;
	case e__BG.XScale: __res = layer_background_get_xscale(__backid); break;
	case e__BG.YScale: __res = layer_background_get_yscale(__backid); break;
	case e__BG.HSpeed: __res = layer_get_hspeed(__layerid); break;
	case e__BG.VSpeed: __res = layer_get_vspeed(__layerid); break;
	case e__BG.Blend: __res = layer_background_get_blend(__backid); break;
	case e__BG.Alpha: __res = layer_background_get_alpha(__backid); break;
	default: break;
	};
	
	return __res;

}

function __background_get_showcolour()
{
	var __colinfo = __background_get_colour_element();
	
	if (__colinfo[0] == -1)
		return 0;
		
	var __visible = layer_background_get_visible(__colinfo[0]);
	return __visible;
}

function __background_set()
{
	var __prop = argument0;
	var __bind = argument1;
	var __val = argument2;
	
	var __backinfo = __background_get_element(__bind);
	
	__background_set_internal(__prop, __bind, __val, __backinfo);
	
	var __res = __background_get_internal(__prop, __bind, __backinfo);
	return __res;
}

function __background_set_colour()
{
	var __newcol = argument0;
	
	var __colinfo = __background_get_colour_element();
	
	if (__colinfo[0] == -1)
		return 0;
		
	layer_background_blend(__colinfo[0], __newcol);
	return __newcol;
}

function __background_set_colour_pp()
{
	var __newcol = argument0;
	
	var __colinfo = __background_get_colour_element();
	
	if (__colinfo[0] == -1)
		return 0;
		
	var __col = layer_background_get_blend(__colinfo[0]);
	layer_background_blend(__colinfo[0], __newcol);
	return __col;
}

function __background_set_element()
{
	// NOTE: this script will only work properly if you're using the standard depth range (-16000 to 16000)
	var __bind = argument0;
	var __vis = argument1;
	var __fore = argument2;
	var __back = argument3;
	var __x = argument4;
	var __y = argument5;
	var __htiled = argument6;
	var __vtiled = argument7;
	var __xscale = argument8;
	var __yscale = argument9;
	var __stretch = argument10;
	var __hspeed = argument11;
	var __vspeed = argument12;
	var __blend = argument13;
	var __alpha = argument14;
	
	//var __nearestdepth = -15000;
	//var __farthestdepth = 15999;
	var __nearestdepth = 1000000000;
	var __farthestdepth = -1000000000;
	var __depthinc = 100;
	
	var __result;
	__result[0] = -1;
	__result[1] = -1;
	
	
	// Now look at the existing layers in the room to see if we have any foregrounds or backgrounds
	var __fgstring = "Compatibility_Foreground_";
	var __bgstring = "Compatibility_Background_";
	var __colstring = "Compatibility_Colour";
	var __fglen = string_length(__fgstring);
	var __bglen = string_length(__bgstring);
	var __layerlist = layer_get_all();
	var __layerlistlength = array_length(__layerlist);
	var __collayer = -1;
	var __slots;
	var __isforeground;
	var __i;
	for(__i = 0; __i < 8; __i++)
	{
		__slots[__i] = -1;
		__isforeground[__i] = false;
	}
	
	
	for(__i = 0; __i < __layerlistlength; __i++)
	{
		var __layername = layer_get_name(__layerlist[__i]);	
		if (string_pos(__fgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __fglen + 1);
			if (__slotchr == "")
				continue;
				
			var __slot = real( __slotchr );
			__slots[__slot] = __layerlist[__i];
			
			__isforeground[__slot] = true;
			
			// Could check the contents of this layer to see if it has a single background element on it but that's probably overkill		
		}
		else if (string_pos(__bgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __bglen + 1);
			if (__slotchr == "")
				continue;
				
			var __slot = real( __slotchr );
			__slots[__slot] = __layerlist[__i];
			
			__isforeground[__slot] = false;
			
			// Could check the contents of this layer to see if it has a single background element on it but that's probably overkill		
		}
		else if (string_pos(__colstring, __layername) > 0)
		{
			// Make sure colour is as deep as it can be
			__collayer = __layerlist[__i];
			layer_depth(__layerlist[__i], __farthestdepth);
		}
		else
		{
			var __currdepth = layer_get_depth(__layerlist[__i]);
			
			if (__currdepth < __nearestdepth)
				__nearestdepth = __currdepth;
				
			if (__currdepth > __farthestdepth)
				__farthestdepth = __currdepth;
		}
	}
	
	// Reassign depths
	__farthestdepth += __depthinc + 1000;		// add some margin for the background layers
	__nearestdepth -= __depthinc;
	
	//__farthestdepth = max(__farthestdepth, 15999);
	//__nearestdepth = min(__nearestdepth, -15000);
	__farthestdepth = max(__farthestdepth, 2147483600);
	__nearestdepth = min(__nearestdepth, -2147482000);
	
	for(__i = 0; __i < 8; __i++)
	{
		if (__slots[__i] != -1)
		{
			var __depth = 0;
			if (__isforeground[__i] == true)
			{
				__depth = __nearestdepth - (__i * __depthinc);
			}
			else
			{
				__depth = (__farthestdepth - __depthinc) - (__slot * __depthinc);
			}
			
			layer_depth(__slots[__i], __depth);
		}
	}
	
	if (__collayer != -1)
	{
		layer_depth(__collayer, __farthestdepth);
	}
	
	
	// Construct our layer name and depth
	var __layername;
	var __layerdepth;
	if (__bind == -1)
	{
		// This is the background colour layer
		__layername = __colstring;
		__layerdepth = __farthestdepth;
	}
	else
	{
		if (__fore == true)
		{
			__layername = __fgstring + string(__bind);
			__layerdepth = __nearestdepth - (__bind * __depthinc);
		}
		else
		{
			__layername = __bgstring + string(__bind);
			__layerdepth = (__farthestdepth - __depthinc) - (__bind * __depthinc);	// reserve 16000 for imported colour
		}
	}
	
	// If we already have a background in this slot, nuke it
	var __layerid;
	if (__bind == -1)
	{
		__layerid = __collayer;
	}
	else
	{
		__layerid = __slots[__bind];
	}
		
	if (__layerid != -1)
	{
		layer_destroy(__layerid);
	}
	__layerid = layer_create(__layerdepth, __layername);
	
	// Set our layer properties
	layer_x(__layerid, __x);
	layer_y(__layerid, __y);
	layer_hspeed(__layerid, __hspeed);
	layer_vspeed(__layerid, __vspeed);
	
	// Construct our new background element
	var __backel = layer_background_create(__layerid, __back);
	layer_background_visible(__backel, __vis);
	layer_background_htiled(__backel, __htiled);
	layer_background_vtiled(__backel, __vtiled);
	layer_background_xscale(__backel, __xscale);
	layer_background_yscale(__backel, __yscale);
	layer_background_stretch(__backel, __stretch);
	layer_background_blend(__backel, __blend);
	layer_background_alpha(__backel, __alpha);
	
	__result[0] = __backel;
	__result[1] = __layerid;
	
	return __result;
}

function __background_set_internal()
{
	var __prop = argument0;
	var __bind = argument1;
	var __val = argument2;
	var __backinfo = argument3;
	
	if (__backinfo[0] == -1)
	{
		return -1;	// erm
	}
	
	var __backid = __backinfo[0];
	var __layerid = __backinfo[1];
	var __isfore = __backinfo[2];
	
	if (__prop == e__BG.Foreground)
	{
		// This requires quite a bit of extra logic (we need to modify our layer list)
		if (round(__val) != round(__isfore))
		{
			// okay, we have a mismatch
			// Get all properties, then set the background again and copy the properties
			var __visible = layer_get_visible(__layerid);
			var __index = layer_background_get_sprite(__backid);
			var __htiled = layer_background_get_htiled(__backid);
			var __vtiled = layer_background_get_vtiled(__backid);
			var __stretch = layer_background_get_stretch(__backid);
			var __blend = layer_background_get_blend(__backid);
			var __alpha = layer_background_get_alpha(__backid);
			var __xscale = layer_background_get_xscale(__backid);
			var __yscale = layer_background_get_yscale(__backid);
	
			var __x = layer_get_x(__layerid);
			var __y = layer_get_y(__layerid);
			var __hspeed = layer_get_hspeed(__layerid);
			var __vspeed = layer_get_vspeed(__layerid);
	
			__background_set_element(__bind, __visible, __val, __index, __x, __y, __htiled, __vtiled,__xscale,__yscale, __stretch, __hspeed, __vspeed, __blend, __alpha);
		}
	}
	else
	{
		switch(__prop)
		{
		case e__BG.Visible: layer_set_visible(__layerid, __val); layer_background_visible(__backid, __val); break;	
		case e__BG.Index: 		
			layer_background_change(__backid, __val);  
			// RK :: if we are setting a sprite then set the background colour to white so it is blending correctly
			if (sprite_exists(__val)) { 
				layer_background_blend(__backid, c_white ); 
				layer_background_alpha(__backid, 1 ); 
			} // end if
			break;
		case e__BG.X: layer_x(__layerid, __val); break;
		case e__BG.Y: layer_y(__layerid, __val); break;
		case e__BG.HTiled: layer_background_htiled(__backid, __val); break;
		case e__BG.VTiled: layer_background_vtiled(__backid, __val); break;
		case e__BG.XScale: layer_background_xscale(__backid, __val); break;
		case e__BG.YScale: layer_background_yscale(__backid, __val); break;
		case e__BG.HSpeed: layer_hspeed(__layerid, __val); break;
		case e__BG.VSpeed: layer_vspeed(__layerid, __val); break;
		case e__BG.Blend: layer_background_blend(__backid, __val); break;
		case e__BG.Alpha: layer_background_alpha(__backid, __val); break;
		default: break;
		};
	}
	
	return -1;

}

function __background_set_pp()
{
	var __prop = argument0;
	var __bind = argument1;
	var __val = argument2;
	
	var __backinfo = __background_get_element(__bind);
	var __res = __background_get_internal(__prop, __bind, __backinfo);
	
	__background_set_internal(__prop, __bind, __val, __backinfo);
	
	return __res;
}

function __background_set_showcolour()
{
	var __newvis = argument0;
	
	var __colinfo = __background_get_colour_element();
	
	if (__colinfo[0] == -1)
		return 0;
		
	layer_background_visible(__colinfo[0], __newvis);
	return __newvis;
}

function __background_set_showcolour_pp()
{
	var __newvis = argument0;
	
	var __colinfo = __background_get_colour_element();
	
	if (__colinfo[0] == -1)
		return 0;
		
	var __vis = layer_background_get_visible(__colinfo[0]);
	layer_background_visible(__colinfo[0], __newvis);
	return __vis;
}

function __init_background()
{
	enum e__BG
	{
		Visible,
		Foreground,
		Index,
		X,
		Y,
		Width,
		Height,
		HTiled,
		VTiled,
		XScale,
		YScale,
		HSpeed,
		VSpeed,
		Blend,
		Alpha,
	};
	

}

#endregion
#region action

function action_another_room()
{
	/// @description (Old DnD) - move to another room
	/// @param roomIndex room index to go to.
	room_goto( argument0 );

}

function action_bounce()
{
	/// @description (Old DnD) - Allows bouncing of the calling instance
	/// @param advanced Whether to enable advanced bouncing (true) or not (false)
	/// @param useall true if bouncing off non-solid and solid
	var __useall = argument1;
	if (!__useall) {
		move_bounce_solid(argument0);
	} else {
		move_bounce_all(argument0);
	}

}

function action_cd_pause()
{
	/// @description action_cd_pause - deprecated function
	show_debug_message( "action_cd_pause is a deprecated function" );
	return 0;
}

function action_cd_play()
{
	/// @description action_cd_play - deprecated function
	show_debug_message( "action_cd_play is a deprecated function" );
	return 0;
}

function action_cd_playing()
{
	/// @description action_cd_playing - deprecated function
	show_debug_message( "action_cd_playing is a deprecated function" );
	return 0;
}

function action_cd_present()
{
	/// @description action_cd_present - deprecated function
	show_debug_message( "action_cd_present is a deprecated function" );
	return 0;
}

function action_cd_resume()
{
	/// @description action_cd_resume - deprecated function
	show_debug_message( "action_cd_resume is a deprecated function" );
	return 0;
}

function action_cd_stop()
{
	/// @description action_cd_stop - deprecated function
	show_debug_message( "action_cd_stop is a deprecated function" );
	return 0;

}

function action_change_object()
{
	/// @description (Old DnD) - Changes the calling instance to an instance of a different object
	/// @param objInd The new object the calling object will change into.
	/// @param performEvents Whether to perform that new object's create and destroy events (true) or not (false).
	instance_change( argument0, argument1 );

}

function action_color()
{
	/// @description (Old DnD) - Sets the base color for the draw functions
	/// @param col The color to set for drawing.
	draw_set_color( argument0 );
}

function action_colour()
{
	/// @description (Old DnD) - Sets the base colour for the draw functions
	/// @param col The colour to set for drawing.
	draw_set_color( argument0 );

}

function action_create_object()
{
	/// @description (Old DnD) - creates an instance of an object at a position
	/// @param objInd object to create
	/// @param xPos		X position to create at
	/// @param yPos		Y position to create at
	
	if (!object_exists(argument0)) {
		show_message( "creating instance for non-existent object" + string(id) );
		return 0;
	}
	
	if (global.__argument_relative)
	{
		instance_create( x+argument1, y+argument2, argument0);
	} else {
		instance_create( argument1, argument2, argument0);
	}
}

function action_create_object_motion()
{
	/// @description (Old DnD) - creates an instance of an object at a position with specified motion
	/// @param objInd object to create
	/// @param xPos		X position to create at
	/// @param yPos		Y position to create at
	/// @param speed 	initial speed of instance
	/// @param speed 	initial direction of instance
	if (!object_exists(argument0)) {
		show_message( "creating instance for non-existent object" + string(id) );
		return 0;
	}
	
	var i = -1;
	if (global.__argument_relative)
	{
		i = instance_create( x+argument1, y+argument2, argument0);
	} else {
		i = instance_create( argument1, argument2, argument0);
	}
	i.speed = argument3;
	i.direction = argument4;
}

function action_create_object_random()
{
	/// @description (Old DnD) - creates an instance of an object (from a choice of 4) at a position
	/// @param objInd0 	possible object to create
	/// @param objInd1 	possible object to create
	/// @param objInd2 	possible object to create
	/// @param objInd3 	possible object to create
	/// @param xPos		X position to create at
	/// @param yPos		Y position to create at
	
	var ob = choose( argument0, argument1, argument2, argument3 );
	
	if (!object_exists(ob)) {
		return 0;
	} // end if
	
	if (global.__argument_relative)	{
		i = instance_create( x+argument4, y+argument5, ob);
	} else {
		i = instance_create( argument4, argument5, ob);
	} // end if
	

}

function action_current_room()
{
	/// @description (Old DnD) - restart the current room
	room_restart();

}

function action_draw_arrow()
{
	/// @description (Old DnD) - draw and arrow
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param size size of the arrow head
	
	var x1 = argument0;
	var y1 = argument1;
	var x2 = argument2;
	var y2 = argument3;
	var size = argument4;
	if (global.__argument_relative) {
		draw_arrow( x+x1, y+y1, x+x2, y+y2, size );
	} else {
		draw_arrow( x1, y1, x2, y2, size );	
	} // end if
}

function action_draw_background()
{
	/// @description (Old DnD) - draw background
	/// @param index resource index
	/// @param x	x position
	/// @param y	y position
	/// @param tiled	true if tiled
	
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	// draw tiled if argument3 is true
	if (argument3) {
		draw_sprite_tiled( argument0, 0, xx, yy )
	} else {
		draw_sprite( argument0, 0, xx, yy );
	} // end if
}

function action_draw_ellipse()
{
	/// @description (Old DnD) - draw ellipse
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param outline	true if outline
	
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	draw_ellipse( xx1, yy1, xx2, yy2, argument4 );

}

function action_draw_ellipse_gradient()
{
	/// @description (Old DnD) - draw ellipse with gradient
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param c1   colour 1
	/// @param c2   colour 2
	
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	draw_ellipse_ext( xx1, yy1, xx2, yy2, argument4, argument5, false );

}

function action_draw_font()
{
	/// @description (Old DnD) - deprecated
	show_debug_message( "action_draw_font deprecated");
}

function action_draw_font_old()
{
	/// @description (Old DnD) - deprecated
	show_debug_message( "action_draw_font_old deprecated");
}

function action_draw_gradient_hor()
{
	/// @description (Old DnD) - draw gradient horizontal
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param c1   colour 1
	/// @param c2   colour 2
	
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	var c1 = argument4;
	var c2 = argument5;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	draw_rectangle_ext( xx1, yy1, xx2, yy2, c1, c2, c2, c1, false );
}

function action_draw_gradient_vert()
{
	/// @description (Old DnD) - draw gradient vertical
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param c1   colour 1
	/// @param c2   colour 2
	
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	var c1 = argument4;
	var c2 = argument5;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	draw_rectangle_ext( xx1, yy1, xx2, yy2, c1, c1, c2, c2, false );

}

function action_draw_health()
{
	/// @description (Old DnD) - draw health
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param c1   colour 1
	/// @param c2   colour 2
	
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	var c1Type = argument4;
	var c2Type= argument5;
	var showBack = argument4;
	var c1=0, c2=0, c3=0;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	switch( c1Type ) {
		case 0: c1=c_black; break;
		case 1: c1=c_black; break;
		case 2: c1=c_gray; break;
		case 3: c1=c_silver; break;
		case 4: c1=c_white; break;
		case 5: c1=c_maroon; break;
		case 6: c1=c_green; break;
		case 7: c1=c_olive; break;
		case 8: c1=c_navy; break;
		case 9: c1=c_purple; break;
		case 10: c1=c_teal; break;
		case 11: c1=c_red; break;
		case 12: c1=c_lime; break;
		case 13: c1=c_yellow; break;
		case 14: c1=c_blue; break;
		case 15: c1=c_fuchsia; break;
		case 16: c1=c_aqua; break;
	} // end switch
	
	switch( c2Type ) {
		case 0: { c2=c_red; c3=c_lime; } break;
		case 1: { c2=c_black; c3=c_white; } break;
		case 2: c2=c_black; break;
		case 3: c2=c_gray; break;
		case 4: c2=c_silver; break;
		case 5: c2=c_white; break;
		case 6: c2=c_maroon; break;
		case 7: c2=c_green; break;
		case 8: c2=c_olive; break;
		case 9: c2=c_navy; break;
		case 10: c2=c_purple; break;
		case 11: c2=c_teal; break;
		case 12: c2=c_red; break;
		case 13: c2=c_lime; break;
		case 14: c2=c_yellow; break;
		case 15: c2=c_blue; break;
		case 16: c2=c_fuchsia; break;
		case 17: c2=c_aqua; break;
	} // end switch
	
	if (c2Type>1) { c3=c2; }
	draw_healthbar( xx1, yy1, xx2, yy2, health, c1, c2, c3, 0, showBack, true );
}

function action_draw_life()
{
	/// @description (Old DnD) - draw life
	/// @param x	x position 
	/// @param y	y position 
	/// @param msg	message to disply before lives
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	draw_text( xx, yy, string_hash_to_newline(argument2)+string(lives));
	

}

function action_draw_life_images()
{
	/// @description (Old DnD) - draw life with images
	/// @param x	x position 
	/// @param y	y position 
	/// @param index sprite index to use
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	var w = sprite_get_width( argument2 );
	for( var i=0; i<lives; ++i) {
		draw_sprite( argument2, 0, xx+(i*w), yy);
	} // end for
	

}

function action_draw_line()
{
	/// @description (Old DnD) - draw line
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	draw_line( xx1, yy1, xx2, yy2 );
}

function action_draw_rectangle()
{
	/// @description (Old DnD) - draw rectangle
	/// @param x1	x position of start point
	/// @param y1	y position of start point
	/// @param x2	x position of end point
	/// @param y2	y position of end point
	/// @param outline	true if outline
	
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if
	
	draw_rectangle( xx1, yy1, xx2, yy2, argument4 );
}

function action_draw_score()
{
	/// @description (Old DnD) - draw score
	/// @param x	x position 
	/// @param y	y position 
	/// @param msg	message to display before score
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	draw_text( xx, yy, string_hash_to_newline(argument2)+string(score));
	

}

function action_draw_sprite()
{
	/// @description (Old DnD) - draw sprite
	/// @param index	sprite index
	/// @param x	x position 
	/// @param y	y position 
	/// @param subimg	sub image number
	
	var index =argument0;
	var xx = argument1;
	var yy = argument2;
	var subimg = argument3;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	if (subimg<0) subimg=image_index;
	draw_sprite(index,subimg, xx, yy);
	

}

function action_draw_text()
{
	/// @description (Old DnD) - draw text
	/// @param msg	text to display
	/// @param x	x position 
	/// @param y	y position 
	
	var msg =argument0;
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	draw_text( xx, yy, string_hash_to_newline(msg));
}

function action_draw_text_transformed()
{
	/// @description (Old DnD) - draw text transformed
	/// @param msg	text to display
	/// @param x	x position 
	/// @param y	y position 
	/// @param xscale	x scale
	/// @param yscale	y scale
	/// @param angle	angle
	
	var msg = argument0;
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	draw_text_transformed( xx, yy, string_hash_to_newline(msg), argument3, argument4, argument5 );
}

function action_draw_variable()
{
	/// @description (Old DnD) - draw variable
	/// @param v    variable to display
	/// @param x	x position 
	/// @param y	y position 
	
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	draw_text( xx, yy, string_hash_to_newline(string(argument0)));

}

function action_effect()
{
	/// @description (Old DnD) - create a particle effect
	/// @param kind particle kind
	/// @param x	x position 
	/// @param y	y position 
	/// @param size	size
	/// @param col	colour
	/// @param below true if below, false if above
	
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	
	if (argument5) {
		effect_create_below( argument0, xx, yy, argument3, argument4 );
	} else {	
		effect_create_above( argument0, xx, yy, argument3, argument4 );
	} // end if
}

function action_end_game()
{
	/// @description (Old DnD) - end the game
	game_end();
}

function action_end_sound()
{
	/// @description (Old DnD) - end the sound
	/// @param soundid sound id
	audio_stop_sound( argument0 );
}

function action_execute_script()
{
	/// @description (Old DnD) - execute script
	script_execute( argument[0], argument[1], argument[2], argument[3], argument[4] );
}

function action_fill_color()
{
	/// @description (Old DnD) - fill color
	show_debug_message( "action_fill_color is deprecated");

}

function action_fill_colour()
{
	/// @description (Old DnD) - fill colour
	show_debug_message( "action_fill_colour is deprecated");
}

function action_font()
{
	/// @description (Old DnD) - set the font and horizontal alignment
	/// @param fontid	font id
	/// @param haligh   horizontal alignment
	draw_set_font( argument0 );
	draw_set_halign( argument1 );
}

function action_fullscreen()
{
	/// @description (Old DnD) - fullscreen
	/// @param type type of fullscreen (1 == not fullscreen, 2 == fullscreen, anything else change what you are )
	switch( argument0 ) {
	case 1: 
		window_set_fullscreen( true ); 
		break;
	case 2: 
		window_set_fullscreen( false ); 
		break;
	default:
		window_set_fullscreen( window_get_fullscreen() ? false : true );
		break;
	} // end switch

}

function action_highscore()
{
	/// @description (Old DnD) - highscore (deprecated)
	show_debug_message( "action_highscore is deprecated");

}

function action_highscore_clear()
{
	/// @description (Old DnD) - highscore clear
	highscore_clear();
}

function action_highscore_show()
{
	/// @description (Old DnD) - highscore show
	var rw = room_width;
	var rh = room_height;
	var xx = rw/2 - 100;
	var yy = rh/2 - 100
	draw_highscore( xx, yy, xx+200, yy+200 );

}

function action_if()
{
	/// @description (Old DnD) - if evaluation
	return argument0;
}

function action_if_aligned()
{
	/// @description (Old DnD) - if aligned evauation
	/// @param xxG 	x alignment value
	/// @param yyG 	y alignment value
	var xxG = argument0;
	var yyG = argument1;
	var ret = false;
	if ((xxG>0) && ((x % xxG)==0) && (yyG>0) && ((y % yyG)==0)) {
		ret = true;
	} // end if
	return ret;

}

function action_if_collision()
{
	/// @description (Old DnD) - if collision evauation
	/// @param xxG 	x value
	/// @param yyG 	y value
	/// @param flag false for free, true for empty check
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	if (argument2) {
		return !place_empty( xx, yy);
	} else {
		return !place_free( xx, yy );
	} // end if

}

function action_if_dice()
{
	/// @description (Old DnD) - if dice evauation
	/// @param v number of sides of the dice
	var ret = true;
	var v = argument0;
	if (v > 1) {
		ret = random( 1000*v ) <= 1000;
	} // endif
	return ret;
}

function action_if_empty()
{
	/// @description (Old DnD) - if empty evauation
	/// @param xx	x value
	/// @param yy 	y value
	/// @param flag true for empty, false for free check
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	if (argument2) {
		return place_empty( xx, yy );
	} else {
		return place_free( xx, yy);
	} // end if

}

function action_if_health()
{
	/// @description (Old DnD) - if health evauation
	/// @param val  value to check against
	/// @param type	type of check (1==<, 2==>, anything else is ==)
	var ret = false;
	switch( argument1 )
	{
		case 1:	ret = (health < argument0); break;	
		case 2:	ret = (health > argument0); break;	
		default:ret = (health == argument0); break;	
	}
	return ret;
}

function action_if_life()
{
	/// @description (Old DnD) - if life evauation
	// @param val  value to check against
	/// @param type	type of check (1==<, 2==>, anything else is ==)
	var ret = false;
	switch( argument1 )
	{
		case 1:	ret = (lives < argument0); break;	
		case 2:	ret = (lives > argument0); break;	
		default:ret = (lives == argument0); break;	
	}
	return ret;
}

function action_if_mouse()
{
	/// @description (Old DnD) - if mouse evauation
	/// @param button	button to check
	var ret = mouse_button_down(argument0) || mouse_button_released(argument0);
	switch( argument0 )
	{
		case 1:	
		case 2:	
		case 3:
			ret = mouse_button_down(argument0) || mouse_button_released(argument0);
			break;
		default:
			ret = (mouse_button == 0);
			break;	
	} // end switch
	return ret;
}

function action_if_next_room()
{
	/// @description (Old DnD) - if next room evauation
	return (room != room_last);
}

function action_if_number()
{
	/// @description (Old DnD) - if number evauation
	/// @param index  instance index to check against
	/// @param value value to compare against
	/// @param type	type of check (1==<, 2==>, anything else is ==)
	var ret = false;
	var n = instance_number(argument0);
	switch( argument2 )
	{
		case 1:	ret = (n < argument1); break;	
		case 2:	ret = (n > argument1); break;	
		default:ret = (n == argument1); break;	
	}
	return ret;
}

function action_if_object()
{
	/// @description (Old DnD) - if object evauation
	/// @param xx 	x value
	/// @param yy 	y value
	/// @param flag false for free, true for empty check
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	
	return place_meeting( xx, yy, argument0);

}

function action_if_previous_room()
{
	/// @description (Old DnD) - if next room evauation
	return (room != room_first);
}

function action_if_question()
{
	// insert code here 
	var ret = show_question( argument0 );
	io_clear();
	return ret;
}

function action_if_score()
{
	/// @description (Old DnD) - if score evauation
	/// @param val  value to check against
	/// @param type	type of check (1==<, 2==>, anything else is ==)
	var ret = false;
	switch( argument1 )
	{
		case 1:	ret = (score < argument0); break;	
		case 2:	ret = (score > argument0); break;	
		default:ret = (score == argument0); break;	
	}
	return ret;
}

function action_if_sound()
{
	/// @description (Old DnD) - if sound evauation
	/// @param index sound index to check
	return audio_is_playing( argument0 );
}

function action_if_variable()
{
	/// @description (Old DnD) - if variable evauation
	/// @param val1  value to check against
	/// @param val2  value2 to check against
	/// @param type	type of check (1=='<', 2=='>', 3=='<=', 4=='>='anything else is ==)
	var ret = false;
	switch( argument2 )
	{
		case 1:	ret = (argument0 < argument1); break;	
		case 2:	ret = (argument0 > argument1); break;	
		case 3:	ret = (argument0 <= argument1); break;	
		case 4:	ret = (argument0 >= argument1); break;	
		default:ret = (argument0 == argument1); break;	
	}
	return ret;
}

function action_inherited()
{
	/// @description (Old DnD) - perform the inherited event
	event_inherited();
	

}

function action_kill_object()
{
	/// @description (Old DnD) - destroy the self object
	instance_destroy();
}

function action_kill_position()
{
	/// @description (Old DnD) - destroy instances at position
	/// @param x	x position 
	/// @param y	y position 
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	position_destroy( xx, yy );
}

function action_linear_step()
{
	/// @description (Old DnD) - linear step
	/// @param x	x position 
	/// @param y	y position 
	/// @param speed	speed
	/// @param checkall	true if checking all
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	mp_linear_step( xx, yy, argument2, argument3 );
}

function action_line_color()
{
	/// @description (Old DnD) - line color
	show_debug_message( "action_line_color is deprecated");

}

function action_line_colour()
{
	/// @description (Old DnD) - line colour
	show_debug_message( "action_line_colour is deprecated");

}

function action_load_game()
{
	/// @description (Old DnD) - load a game
	/// @param filename filename
	game_load( argument0 );
}

function action_message()
{
	/// @description (Old DnD) - show a message in a dialog box
	/// @param msg message
	show_message( argument0 );
	io_clear();
}

function action_move()
{
	/// @description (Old DnD) - move the current instance in a direction
	/// @param dir string of 0's and 1's that indicates a valid direction
	/// @param speed speed to move
	if (argument0 == "000000000") return;
	
	var spd = argument1;
	if (global.__argument_relative) {
		spd += speed;
	}  // end if
	
	speed = spd;
	
	// find a valid direction
	var d = irandom(9);
	while( string_char_at(argument0, d+1) != "1" ) {
		d = irandom(9);
	} // end while
	
	switch(d)
	{
		case 0: direction = 225; break;
		case 1: direction = 270; break;
		case 2: direction = 315; break;
		case 3: direction = 180; break;
		case 4: direction = 0; speed = 0; break;
		case 5: direction = 0; break;
		case 6: direction = 135; break;
		case 7: direction = 90; break;
		case 8: direction = 45; break;
	}

}

function action_move_contact()
{
	/// @description (Old DnD) - move the current instance until contact
	/// @param dir direction
	/// @param maxdist maximum distance
	/// @param useall true if using all
	if (argument2) {
		move_contact_all( argument0, argument1 );
	} else {
		move_contact_solid( argument0, argument1 );
	}
	

}

function action_move_point()
{
	/// @description (Old DnD) - move towards point
	/// @param x	x position 
	/// @param y	y position 
	/// @param speed	speed
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	move_towards_point( xx, yy, argument2);
}

function action_move_random()
{
	/// @description (Old DnD) - move random
	/// @param x	x grid
	/// @param y	y grid
	
	var xmin=0, xmax=room_width;
	var ymin=0, ymax=room_height;
	if (sprite_exists(sprite_index) || sprite_exists(mask_index)) {
		xmin = round(x - bbox_left);
		xmax = round(xmax + x - bbox_right);
		ymin = round(y - bbox_top);
		ymax = round(ymax + y - bbox_bottom);
	}
	
	var sx = argument0;
	var sy = argument1;
	for( var i=0; i<100; ++i) {
		var xx = xmin + irandom( xmax-xmin );
		if (sx > 0) xx = sx * floor(xx/sx);
		var yy = ymin + irandom( ymax - ymin );
		if (sy > 0) yy = sy * floor(yy/sy);
		if (place_free( xx, yy)) {
			x = xx;
			y = yy;
			return;
		} // end if
	} // end for

}

function action_move_start()
{
	/// @description (Old DnD) - move start
	x = xstart;
	y = ystart;
	

}

function action_move_to()
{
	/// @description (Old DnD) - move to
	/// @param x	x position 
	/// @param y	y position 
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	x = xx;
	y = yy;
}

function action_next_room()
{
	/// @description (Old DnD) - next room
	room_goto_next();

}

function action_partemit_burst()
{
	/// @description (Old DnD) - particle system emitter burst
	/// @param index emitter index
	/// @param ptype particle type
	/// @param num number
	
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		show_message( "The particle emitter must first be created" );
		return;
	} // end if
	var ptype = argument1;
	var num = argument2;
	part_emitter_burst(global.__part_syst,  global.__part_emit[index], ptype, num )
}

function action_partemit_create()
{
	/// @description (Old DnD) - particle system emitter create in a region
	/// @param index emitter index
	/// @param shape shape to use
	/// @param xMin	x min
	/// @param xMax	x max
	/// @param yMin	y min
	/// @param yMax	y max
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		global.__part_emit[index] = part_emitter_create(global.__part_syst);
	} // end if
	part_emitter_region( global.__part_syst, global.__part_emit[index], argument2, argument3, argument4, argument5, argument1, 0);
}

function action_partemit_destroy()
{
	/// @description (Old DnD) - particle system emitter destroy
	/// @param index emitter index
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		return;
	} // end if
	part_emitter_destroy( global.__part_syst, global.__part_emit[index]);
}

function action_partemit_stream()
{
	/// @description (Old DnD) - particle system emitter stream
	/// @param index emitter index
	/// @param ptype particle type
	/// @param num number
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		show_message( "The particle emitter must first be created" );
		return;
	} // end if
	var ptype = argument1;
	var num = argument2;
	part_emitter_stream(global.__part_syst,  global.__part_emit[index], ptype, num )
}

function action_partsyst_clear()
{
	/// @description (Old DnD) - particle system clear
	if (global.__part_syst >= 0) { 
		part_system_clear( global.__part_syst ); 
	}

}

function action_partsyst_create()
{
	/// @description (Old DnD) - particle system create
	/// @param depth 
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	part_system_clear(global.__part_syst);
	part_system_depth(global.__part_syst, argument0);
	for( var i=0; i<=15; ++i) {
		global.__part_type[i] = -1;
		global.__part_emit[i] = -1;
	} // end for

}

function action_partsyst_destroy()
{
	/// @description (Old DnD) - particle system destroy
	if (global.__part_syst >= 0) { 
		part_system_destroy(global.__part_syst);
	}
	global.__part_syst = -1;

}

function action_parttype_color()
{
	/// @description (Old DnD) - particle type set color
	/// @param index type index
	/// @param type particle type
	/// @param col1 colour 1
	/// @param col2 colour 2
	/// @param alpha1 alpha 1
	/// @param alpha2 alpha 2
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	if (argument1 == 0) {
		part_type_color_mix(global.__part_type[index], argument2, argument3);
	} else {
		part_type_color2(global.__part_type[index], argument2, argument3);
	}
	part_type_alpha2(global.__part_type[index], argument4, argument5 );

}

function action_parttype_colour()
{
	/// @description (Old DnD) - particle type set colour
	/// @param index type index
	/// @param type particle type
	/// @param col1 colour 1
	/// @param col2 colour 2
	/// @param alpha1 alpha 1
	/// @param alpha2 alpha 2
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	if (argument1 == 0) {
		part_type_colour_mix(global.__part_type[index], argument2, argument3);
	} else {
		part_type_colour2(global.__part_type[index], argument2, argument3);
	}
	part_type_alpha2(global.__part_type[index], argument4, argument5 );

}

function action_parttype_create()
{
	/// @description (Old DnD) - particle type create
	/// @param index type index
	/// @param shape
	/// @param sprite sprite index
	/// @param sizeMin minimum size
	/// @param sizeMax maximum size
	/// @param sizeIncr size increments
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_shape(global.__part_type[index], argument1 );
	part_type_sprite(global.__part_type[index], argument2, true, false, false );
	part_type_size(global.__part_type[index], argument3, argument4, argument5, 0 );

}

function action_parttype_create_old()
{
	/// @description (Old DnD) - particle type create (older version)
	/// @param index type index
	/// @param shape
	/// @param sizeMin minimum size
	/// @param sizeMax maximum size
	/// @param colStart colour at start
	/// @param colEnd colour at end
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_shape(global.__part_type[index], argument1 );
	part_type_size(global.__part_type[index], argument2, argument3, 0, 0 );
	part_type_colour2(global.__part_type[index], argument4, argument5 );

}

function action_parttype_gravity()
{
	/// @description (Old DnD) - particle type gravity
	/// @param index type index
	/// @param gravity magnitude of gravity
	/// @param direction direction of gravity
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_gravity(global.__part_type[index], argument1, argument2 );

}

function action_parttype_life()
{
	/// @description (Old DnD) - particle type life
	/// @param index type index
	/// @param lifeMin minimum lifetime
	/// @param lifeMax maximum lifetime
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_life(global.__part_type[index], argument1, argument2 );
}

function action_parttype_secondary()
{
	/// @description (Old DnD) - particle type secondary
	/// @param index type index
	/// @param stepType
	/// @param stepNumber 
	/// @param deathType
	/// @param deathNumber
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_step(global.__part_type[index], argument2, global.__part_type[argument1] );
	part_type_death(global.__part_type[index], argument4, global.__part_type[argument3] );

}

function action_parttype_speed()
{
	/// @description (Old DnD) - particle type speed
	/// @param index type index
	/// @param speedMin
	/// @param speedMax
	/// @param dirMin
	/// @param dirMax
	/// @param stepInc
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_speed(global.__part_type[index], argument1, argument2, -argument5, 0 );
	part_type_direction(global.__part_type[index], argument3, argument4, 0, 0 );

}

function action_path()
{
	/// @description (Old DnD) - path start
	/// @param index path index
	/// @param speed
	/// @param endAct
	/// @param relative
	path_start( argument0, argument1, argument2, argument3 );
}

function action_path_end()
{
	/// @description (Old DnD) - path end
	path_end();
}

function action_path_old()
{
	/// @description (Old DnD) - path old
	show_debug_message( "action_path_old is deprecated");

}

function action_path_position()
{
	/// @description (Old DnD) - set path position
	/// @param position new position
	var pos = argument0;
	if (global.__argument_relative) {
		pos += path_position;
	}  // end if
	path_position = pos;
}

function action_path_speed()
{
	/// @description (Old DnD) - set path speed
	/// @param speed new speed
	var spd = argument0;
	if (global.__argument_relative) {
		spd += path_speed;
	}  // end if
	path_speed = spd;
}

function action_potential_step()
{
	/// @description (Old DnD) - potential step
	/// @param x	x position 
	/// @param y	y position 
	/// @param speed	speed
	/// @param checkall	true if checking all
	
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	mp_potential_step( xx, yy, argument2, argument3 );
}

function action_previous_room()
{
	/// @description (Old DnD) - previous room
	room_goto_previous();

}

function action_replace_background()
{
	/// @description (Old DnD) - replace background
	/// @param index sprite index
	/// @param filename filename to replace
	//sprite_replace( argument0, argument1 );

}

function action_replace_sound()
{
	/// @description (Old DnD) - replace sound (deprecated)
	/// @param index sound index
	/// @param filename filename to replace
	show_debug_message( "action_replace_sound is deprecated")

}

function action_replace_sprite()
{
	/// @description (Old DnD) - replace sprite
	/// @param index sprite index
	/// @param filename filename to replace
	//sprite_replace( argument0, argument1 );

}

function action_restart_game()
{
	/// @description (Old DnD) - restart game
	game_restart();

}

function action_reverse_xdir()
{
	/// @description (Old DnD) - reverse x direction
	hspeed = -hspeed;

}

function action_reverse_ydir()
{
	/// @description (Old DnD) - reverse y direction
	vspeed = -vspeed;

}

function action_save_game()
{
	/// @description (Old DnD) - save game
	/// @param filename filename to save to
	game_save( argument0 );

}

function action_set_alarm()
{
	/// @description (Old DnD) - set alarm
	/// @param index alarm index
	/// @param val value to set to
	alarm_set( argument1, argument0 );

}

function action_set_caption()
{
	/// @description (Old DnD) - set caption
	/// @param enableScoreCaption	true if score caption enabled
	/// @param ScoreCaption	message of score caption
	/// @param enableLivesCaption	true if lives caption enabled
	/// @param LivesCaption	message of lives caption
	/// @param enableHealthCaption	true if health caption enabled
	/// @param HealthCaption	message of health caption
	show_score = argument0;
	caption_score = argument1;
	show_lives = argument2;
	caption_lives = argument3;
	show_health = argument4;
	caption_health = argument5;
}

function action_set_cursor()
{
	/// @description (Old DnD) - set cursor
	/// @param sprIndex sprite index to use for cursor
	/// @param showCursor true if cursor to be showin
	cursor_sprite = argument0;
	if (argument1) {
		window_set_cursor( 0 );
	} else {
		window_set_cursor( -1 );
	} // end if

}

function action_set_friction()
{
	/// @description (Old DnD) - set friction
	/// @param val value to set friction
	var val = argument0;
	if (global.__argument_relative) {
		val += friction;
	}  // end if
	friction = val;

}

function action_set_gravity()
{
	/// @description (Old DnD) - set gravity
	/// @param dir direction for gravity
	/// @param val value to set gravity
	var dir = argument0;
	var val = argument1;
	if (global.__argument_relative) {
		dir += gravity_direction;
		val += gravity;
	}  // end if
	gravity = val;
	gravity_direction = dir;

}

function action_set_health()
{
	/// @description (Old DnD) - set health
	/// @param val value to set health
	var val = argument0;
	if (global.__argument_relative) {
		val += health;
	}  // end if
	health = val;

}

function action_set_hspeed()
{
	/// @description (Old DnD) - set hspeed
	/// @param val value to set hspeed
	var val = argument0;
	if (global.__argument_relative) {
		val += hspeed;
	}  // end if
	hspeed = val;

}

function action_set_life()
{
	/// @description (Old DnD) - set lives
	/// @param val value to set lives
	var val = argument0;
	if (global.__argument_relative) {
		val += lives;
	}  // end if
	lives = val;

}

function action_set_motion()
{
	/// @description (Old DnD) - set motion
	/// @param dir direction
	/// @param spd speed
	var dir = argument0;
	var spd = argument1;
	if (global.__argument_relative) {
		dir += direction;
		spd += speed;
	}  // end if
	direction = dir;
	speed = spd;

}

function action_set_relative()
{
	/// @description (Old DnD) - set argument relative
	/// @param val value to set argument relative variable
	global.__argument_relative = argument0;
	

}

function action_set_score()
{
	/// @description (Old DnD) - set score
	/// @param val value to set score
	var val = argument0;
	if (global.__argument_relative) {
		val += score;
	}  // end if
	score = val;

}

function action_set_sprite()
{
	/// @description (Old DnD) - set sprite
	/// @param index sprite index
	/// @param scale scale
	image_index = argument0;
	if (argument1 > 0) {
		image_xscale = argument1;	
		image_yscale = argument1;	
	} // end if

}

function action_set_timeline()
{
	/// @description (Old DnD) - set timeline
	/// @param index sprite index
	/// @param pos  timeline position
	timeline_index = argument0;
	timeline_position = argument1;
	timeline_running = true;

}

function action_set_timeline_position()
{
	/// @description (Old DnD) - set timeline position
	/// @param pos  timeline position
	var val = argument0;
	if (global.__argument_relative) {
		val += timeline_position;
	}  // end if
	timeline_position = val;

}

function action_set_timeline_speed()
{
	/// @description (Old DnD) - set timeline speed
	/// @param val timeline speed
	var val = argument0;
	if (global.__argument_relative) {
		val += timeline_speed;
	}  // end if
	timeline_speed = val;

}

function action_set_vspeed()
{
	/// @description (Old DnD) - set vspeed
	/// @param val value to set vspeed
	var val = argument0;
	if (global.__argument_relative) {
		val += vspeed;
	}  // end if
	vspeed = val;

}

function action_show_info()
{
	/// @description (Old DnD) - show info (deprecated)
	io_clear();

}

function action_show_video()
{
	/// @description (Old DnD) - show video (deprecated)
	io_clear();

}

function action_sleep()
{
	/// @description (Old DnD) - sleep (deprecated)
	sleep( argument0 );

}

function action_snap()
{
	/// @description (Old DnD) - move snap
	/// @param hsnap horizontal snap value
	/// @param vsnap vertical snap value
	move_snap( argument0, argument1 );

}

function action_snapshot()
{
	/// @description (Old DnD) - snapshot
	/// @param filename filename for save file
	surface_save( application_surface, argument0 );

}

function action_sound()
{
	/// @description (Old DnD) - play sound
	/// @param index sound index
	/// @param loop true if playing a loop
	audio_play_sound( argument0, 1, argument1 );

}

function action_splash_web()
{
	/// @description (Old DnD) - action splash web (deprecated)
	show_debug_message( "action_splash_web is deprecated");
}

function action_sprite_color()
{
	/// @description (Old DnD) - set sprite color (and alpha)
	/// @param color color
	/// @param alpha alpha
	image_blend = argument0;
	image_alpha = argument1;
	

}

function action_sprite_colour()
{
	/// @description (Old DnD) - set sprite colour (and alpha)
	/// @param colour colour
	/// @param alpha alpha
	image_blend = argument0;
	image_alpha = argument1;

}

function action_sprite_set()
{
	/// @description (Old DnD) - set sprite set
	/// @param index sprite index
	/// @param image image number
	/// @param speed image speed
	sprite_index = argument0;
	if (argument1 >= 0) image_index = argument1;
	image_speed = argument2;
}

function action_sprite_transform()
{
	/// @description (Old DnD) - set sprite transform
	/// @param scaleX x scale of sprite
	/// @param scaleY y scale of sprite
	/// @param angle angle of sprite
	/// @param third ???? quadrant ????
	image_xscale = argument0;
	image_yscale = argument1;
	image_angle = argument2;
	if ((argument3 == 1) || (argument3 == 3)) image_xscale=-image_xscale;
	if ((argument3 == 2) || (argument3 == 3)) image_yscale=-image_yscale;

}

function action_timeline_pause()
{
	/// @description (Old DnD) - set timeline pause
	timeline_running = false;

}

function action_timeline_set()
{
	/// @description (Old DnD) - set timeline
	/// @param index timeline index
	/// @param pos timeline position
	/// @param running timeline running (0/false = yes)
	/// @param loop timeline looping (true = yes)
	timeline_index = argument0;
	timeline_position = argument1;
	timeline_running = !argument2;
	timeline_loop = argument3;

}

function action_timeline_start()
{
	/// @description (Old DnD) - set timeline start
	timeline_running = true;

}

function action_timeline_stop()
{
	/// @description (Old DnD) - set timeline stop
	timeline_position = 0;
	timeline_running = false;

}

function action_webpage()
{
	/// @description (Old DnD) - show webpage
	/// @param cmd page to show
	execute_shell( argument0, "" );

}

function action_wrap()
{
	/// @description (Old DnD) - motion wrap
	/// @param index  (0 || 2 ) horizontal wrap (1 || 2 ) vertical wrap
	
	var w = sprite_width;
	var h = sprite_height;
	
	if ((argument0 == 0) || (argument0 == 2)) {
	
		if (hspeed < 0) && (x < 0)
			x += room_width + w;
		if (hspeed > 0) && (x >= room_width)
			x -= room_width + w;
	} // end if
	
	if ((argument0 == 1) || (argument0 == 2)) {
	
		if (vspeed < 0) && (y < 0)
			y += room_height + h;
		if (vspeed > 0) && (y >= room_height)
			y -= room_height + h;
	} // end if

}

function __init_action()
{
	gml_pragma( "global", "__init_action();");
	global.__part_syst=-1;
	global.__part_emit=[];
	global.__argument_relative=false;
	global.__part_type=[];
	
	for( var i=0; i<=15; ++i) 
	{
		global.__part_type[i] = -1;
		global.__part_emit[i] = -1;
	}
}

#endregion
